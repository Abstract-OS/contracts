<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>a</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quick_start.html"><strong aria-hidden="true">2.</strong> Quick-start</a></li><li class="chapter-item expanded "><a href="tutorial/index.html"><strong aria-hidden="true">3.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/interfaces.html"><strong aria-hidden="true">3.1.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="tutorial/env-variable.html"><strong aria-hidden="true">3.2.</strong> Environment Vars</a></li><li class="chapter-item expanded "><a href="tutorial/scripting.html"><strong aria-hidden="true">3.3.</strong> Scripting</a></li><li class="chapter-item expanded "><a href="tutorial/integration-tests.html"><strong aria-hidden="true">3.4.</strong> Integration Tests</a></li><li class="chapter-item expanded "><a href="tutorial/integration.html"><strong aria-hidden="true">3.5.</strong> Product Integrations</a></li></ol></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">4.</strong> Contributing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="abstract">Abstract</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">a</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="abstract-sdk"><a class="header" href="#abstract-sdk">Abstract SDK</a></h1>
<p><img src="./assets/docs_bg.png" alt="SDK Background" /></p>
<p>Welcome to the Abstract documentation, your comprehensive guide to understanding and utilizing Abstract - the chain-agnostic CosmWasm framework that empowers developers to create, monetize, and deploy modular and scalable decentralized applications. This guide will walk you through essential concepts, key features, and real-world examples to help you harness the full potential of the Abstract ecosystem.</p>
<h2 id="what-is-abstract"><a class="header" href="#what-is-abstract">What is Abstract?</a></h2>
<p>Abstract is a cutting-edge smart contract framework designed for the CosmWasm ecosystem, enabling developers to build and monetize decentralized applications (dApps) using a modular component system. It simplifies and streamlines the dApp development process by offering an extensive library of off-the-shelf modules and a custom SDK for seamless integration with popular tools and services.</p>
<h2 id="key-features-and-benefits"><a class="header" href="#key-features-and-benefits">Key Features and Benefits</a></h2>
<ul>
<li>
<p>Modular Design: Abstract's modular architecture allows developers to choose from a curated library of modules or develop their own using the Abstract SDK, enabling rapid development and customization.</p>
</li>
<li>
<p>Chain-Agnostic: Abstract is built to support various blockchain networks within the Cosmos ecosystem, giving developers the flexibility to choose the best-suited platform for their dApp.</p>
</li>
<li>
<p>Custom Governance: Abstract allows developers to create custom governance structures tailored to their application's specific requirements, including integration with multisignature wallets and DAOs.</p>
</li>
<li>
<p>Testing Infrastructure (cw-orchestrator): Abstract offers a vast integration testing library, enabling developers to quickly increase test coverage and ensure the reliability of their dApps.</p>
</li>
<li>
<p>Version Management: Abstract simplifies the process of upgrading installed modules, ensuring developers can quickly access new features and bug-fixes.</p>
</li>
<li>
<p>Ecosystem Integrations: Abstract is designed to work seamlessly with popular projects and services in the Cosmos ecosystem, such as:</p>
<ul>
<li>Dexes: WyndDex, Osmosis, Astroport, and TerraSwap</li>
<li>Oracles: Ojo Network (planned)</li>
<li>Wallets: Keplr, Cosmostation and Terra Station</li>
<li>Automation: CronCat and Lit Protocol (planned)</li>
</ul>
</li>
</ul>
<h3 id="reliable-development-funding"><a class="header" href="#reliable-development-funding">Reliable Development Funding</a></h3>
<p>Developers on the Abstract platform can earn ongoing revenue for their contributions by leveraging the platform's tokenomics and community-driven incentives. They design and offer modules on the Module Marketplace and receive a portion of Abstract tokens from each sale. By participating in or forming Developer DAOs, developers gain access to funding for building modules and dApps, sharing profits among members. Furthermore, they can create modules based on user bounties, earning tokens for their efforts. This collaborative environment encourages the creation of top-quality modules, offering developers a continuous income stream and promoting value for all parties involved.</p>
<h2 id="use-cases-and-examples"><a class="header" href="#use-cases-and-examples">Use Cases and Examples</a></h2>
<h3 id="personalized-decentralized-finance-pdefi"><a class="header" href="#personalized-decentralized-finance-pdefi">Personalized Decentralized Finance (PDeFi)</a></h3>
<p>Developers can leverage Abstract's modular architecture to quickly build Personalized DeFi applications. In contrast with traditionally DeFi, these applications aren't required to custody the user's assets. They can also be customized to meet the user's specific requirements, such as integrating with their preferred oracle, wallet, or exchange. Abstract's P-DeFi applications can be used to create custom financial products, such as:</p>
<ul>
<li>Dollar cost averaging (DCA)</li>
<li>Grid bot trading</li>
<li>Custom trading strategies</li>
<li>Permissioned asset markets</li>
</ul>
<p>All of which can have tweakable settings that are in the user's control.</p>
<h3 id="nft-marketplaces"><a class="header" href="#nft-marketplaces">NFT Marketplaces</a></h3>
<p>Abstract's SDK can be used to create customizable NFT marketplaces, allowing users to mint, trade, and manage digital assets on various Cosmos-based blockchains.</p>
<h3 id="governance-platforms"><a class="header" href="#governance-platforms">Governance Platforms</a></h3>
<p>Developers can utilize Abstract to create advanced governance platforms that support custom voting mechanisms and proposal systems for community-driven decision-making.</p>
<h3 id="cross-chain-interoperability"><a class="header" href="#cross-chain-interoperability">Cross-Chain Interoperability</a></h3>
<p>Abstract's chain-agnostic nature enables developers to create dApps that can interact with multiple blockchains within the Cosmos ecosystem, facilitating cross-chain asset transfers and communication.</p>
<h3 id="decentralized-autonomous-organizations-daos"><a class="header" href="#decentralized-autonomous-organizations-daos">Decentralized Autonomous Organizations (DAOs)</a></h3>
<p>Abstract can be used to build and manage DAOs with custom governance structures, allowing communities to collaborate, make decisions, and allocate resources effectively.</p>
<h3 id="project-infrastructure"><a class="header" href="#project-infrastructure">Project Infrastructure</a></h3>
<p>Develop tooling for your dApps that help speed up work flows, work with your contracts from inside Rust, no need for JavaScript, use your own Rust projects codebases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abstract-quick-start-todo"><a class="header" href="#abstract-quick-start-todo">Abstract quick-start (TODO)</a></h1>
<p>Getting started with cw-orchestrator is very easy. The first step to using orchestrator is adding <code>cw-orch</code> to your contract's toml.</p>
<h2 id="add-cw-orch"><a class="header" href="#add-cw-orch">Add <code>cw-orch</code></a></h2>
<p>You can do this by running the following in the directory of your contract:</p>
<pre><code class="language-shell">$ cargo add --optional cw-orch
&gt; Adding cw-orch v0.10.0 to optional dependencies.
</code></pre>
<p>Or you can add it manually in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
cw-orch = {version = &quot;0.10.0&quot;, optional = true } # Latest version at time of writing
</code></pre>
<p>Now that we have added <code>cw-orch</code> as an optional dependency we will want to enable it through a feature. This ensures that the code added by <code>cw-orch</code> is not included in the wasm artifact of the contract. To do this add an <code>interface</code> feature to the <code>Cargo.toml</code> and enable <code>cw-orch</code> when it is enabled.</p>
<p>To do this include the following in the <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[features]
interface = [&quot;dep:cw-orch&quot;]
</code></pre>
<blockquote>
<p>You can learn more about Rust features <a href="https://doc.rust-lang.org/cargo/reference/features.html">here</a>.</p>
</blockquote>
<h2 id="contract-interface"><a class="header" href="#contract-interface">Contract Interface</a></h2>
<p>Now that we have the dependency set up you can add the <code>interface</code> macro to your contract's endpoints. This macro will generate an interface to your contract that you will be able to use to interact with your contract. Get started by adding the feature-flagged interface macro to the contract's endpoints:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In `contract.rs`
#[cfg_attr(feature=&quot;interface&quot;, cw_orch::interface_entry_point)] // &lt;--- Add this line
pub fn instantiate(
   deps: DepsMut,
   env: Env,
   info: MessageInfo,
   msg: InstantiateMsg,
 -&gt; StdResult&lt;Response&gt; {
    // ...
}

#[cfg_attr(feature=&quot;interface&quot;, cw_orch::interface_entry_point)] // &lt;--- Add this line
pub fn execute(
   deps: DepsMut,
   env: Env,
   info: MessageInfo,
   msg: ExecuteMsg,
 -&gt; StdResult&lt;Response&gt; {
    // ...
}
// ... Do the same for the other entry points (query, migrate, reply, sudo)
<span class="boring">}</span></code></pre></pre>
<p>By adding these lines we generate code whenever the <code>interface</code> macro is enabled.
The code will generate a contract interface. The contract interface will be the PascalCase of the crate's name.</p>
<blockquote>
<p>The name of the crate is defined in the <code>Cargo.toml</code> file of your contract.</p>
</blockquote>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Let's look at an example to solidify your understanding.
We have a contract with a <code>Cargo.toml</code> file roughly be like the following:</p>
<pre><code class="language-toml"># Cargo.toml
[package]
name = &quot;example-contract&quot;
# ...

[features]
# Features that are enabled by default
default = [&quot;export&quot;]
# Exports the WASM entry points, similar to the `library` feature
export = []
# Enables the contracts's interface
interface = [&quot;dep:cw-orch&quot;]

[dependencies]
cw-orch = {version = &quot;0.10.0&quot;, optional = true }
# ...
</code></pre>
<p>Then our contract looks something like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// contract.rs
#[cfg_attr(feature = &quot;export&quot;, entry_point)]
#[cfg_attr(feature = &quot;interface&quot;, cw_orch::interface_entry_point)]
pub fn instantiate(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    // Instantiate contract
    Ok(Response::default())
}

#[cfg_attr(feature = &quot;export&quot;, entry_point)]
#[cfg_attr(feature = &quot;interface&quot;, cw_orch::interface_entry_point)]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    match msg {
        // match statements
        _ =&gt; todo!()
    }
}

#[cfg_attr(feature = &quot;export&quot;, entry_point)]
#[cfg_attr(feature = &quot;interface&quot;, cw_orch::interface_entry_point)]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
    match msg {
        // match statements
        _ =&gt; todo!()
    }
}

#[cfg_attr(feature = &quot;export&quot;, entry_point)]
#[cfg_attr(feature = &quot;interface&quot;, cw_orch::interface_entry_point)]
pub fn migrate(deps: DepsMut, env: Env, msg: MigrateMsg) -&gt; Result&lt;Response, ContractError&gt; {
    // ...
    Ok(Response::default())
}
<span class="boring">}</span></code></pre></pre>
<p>This macro generates a <code>ExampleContract</code> struct that is now available in <code>contract.rs</code>.</p>
<p>If we now create a test in <code>contract/tests</code> we can start interacting with it!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// contract/tests/example.rs

// import the generated interface
use example_contract::contract::ExampleContract;
#[test]
fn example_test() {
    // init mock environment
    let sender = Addr::unchecked(&quot;sender&quot;);
    // Init the mock environment (cw-multi-test App)
    let mock = Mock::new(&amp;sender);
    // `new()` function is available to construct the contract interface
    let example_contract = ExampleContract::new(&quot;example_contract&quot;, mock);
    // Now we can start scripting!

    // Upload the contract to the mock
    example_contract.upload()?;

    // Instantiate the contract
    example_contract.instantiate(&amp;InstantiateMsg { ... }, None, None)?;

    // Execute the newly instantiated contract
    example_contract.execute(&amp;ExecuteMsg::Increment { ... }, None)?;

    // Query
    let resp: QueryResponse = example_contract.query(&amp;QueryMsg::Config { ... })?;

    // Migrate
    example_contract.migrate(&amp;MigrateMsg { ... }, None)?;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="interaction-helpers"><a class="header" href="#interaction-helpers">Interaction helpers</a></h2>
<p>cw-orchestrator provides an additional macro to simplify contract calls and queries. The macro generates functions on the interface for each variant of the contract's ExecuteMsg and QueryMsg.</p>
<p>Enabling this functionality is very straight-forward. Find your <code>ExecuteMsg</code> and <code>QueryMsg</code> definitions and add the <code>ExecuteFns</code> and <code>QueryFns</code> derive macros to them like below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[cfg_attr(feature = &quot;interface&quot;, derive(ExecuteFns))]
pub enum ExecuteMsg {
    Increment {},
    ...
}

#[cfg_attr(feature = &quot;interface&quot;, derive(QueryFns))]
pub enum QueryMsg {
    #[returns(ConfigResponse)]
    Config {}
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>Any variant of the <code>ExecuteMsg</code> and <code>QueryMsg</code> that has a <code>#[derive(ExecuteFns)]</code> or <code>#[derive(QueryFns)]</code> will have a function generated on the interface through a trait. The function will have the same name as the variant and will take the same arguments as the variant.</p>
<p>You can access these functions by importing the generated traits form the message file. The generated traits are named <code>ExecuteMsgFns</code> and <code>QueryMsgFns</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// Import the generated traits
use example_contract::msg::{ExecuteMsgFns, QueryMsgFns};

#[test]
fn example_test() {
    // init mock environment
    let sender = Addr::unchecked(&quot;sender&quot;);
    // Init the mock environment (cw-multi-test App)
    let mock = Mock::new(&amp;sender);
    // `new()` function is available to construct the contract interface
    let example_contract = ExampleContract::new(&quot;example_contract&quot;, mock);

    // ... upload and instantiate like before

    // Execute the increment endpoint
    example_contract.increment()?;

    // Query the config
    // Return type optional!
    let resp: QueryResponse = example_contract.config()?;
}

<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>The function arguments are ordered alphabetically to prevent breaking changes when struct fields are moved.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<p>In order to use cw-orchestrator you need access to the entry point message types (<code>InstantiateMsg</code>,<code>ExecuteMsg</code>,...) of the contracts you want to interact with.</p>
<p>If you want to perform on-chain transaction you also need access to the gRPC endpoint of a node. These are most-often available on port 9090.</p>
<blockquote>
<p>If you're unsure as to what the gRPC endpoint of your chain is, check the <a href="https://cosmos.directory">Cosmos Directory</a> and there should be some listed. cw-orchestrator ships with a set of urls that should contain at least one working endpoint. Feel free to add urls to the list and PR them!</p>
</blockquote>
<p>The following sections detail setting up a library package for the contract interfaces and a binary package for executable scripts.</p>
<p>Following this example, the project's structure should eventually look like:</p>
<pre><code class="language-path">.
├── Cargo.toml
├── artifacts
│   └── my_contract.wasm (binary file)
├── my-contract
│   ├── Cargo.toml
│   └── src
│       ├── contract.rs (execute, instantiate, query, ...)
│       └── ..
├── packages
│   ├── my-project
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── lib.rs
│   │       └── my-contract.rs (msgs)
│   └── interfaces
│       ├── Cargo.toml
│       └── src
│            └── lib.rs
│            └── my-contract.rs (interface_entry_point)
└── scripts
    ├── .env
    ├── Cargo.toml
    └── src
        ├── deploy.rs
        └── test_my_contract.rs
</code></pre>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<ul>
<li><strong><a href="tutorial/./interfaces.html">Interfaces</a></strong>
<ul>
<li>Define interfaces for your contracts.</li>
</ul>
</li>
<li><strong><a href="tutorial/./env-variable.html">Environment File</a></strong>
<ul>
<li>Configure your mnemonics and log settings.</li>
</ul>
</li>
<li><strong><a href="tutorial/./scripting.html">Scripting</a></strong>
<ul>
<li>Write runnable scripts with your interfaces.</li>
</ul>
</li>
<li><strong><a href="tutorial/./integration.html">Integration</a></strong>
<ul>
<li>Export a deployment of your application for use in integration testing.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h1>
<p>To get started with cw-orchestrator, create a new folder in your project's package directory and add it to the workspace members.</p>
<pre><code class="language-shell">cd packages
cargo init --lib interfaces
cd interfaces
</code></pre>
<p>Now add <a href="https://crates.io/crates/cw-orch">cw-orchestrator</a> to <code>Cargo.toml</code> along with the package that contains the contract's endpoint messages.</p>
<pre><code class="language-bash">cargo add cw-orch
cargo add log # optional for logging
cargo add anyhow # optional for simple error handling
cargo add --path ../my-project
</code></pre>
<pre><code class="language-toml">[dependencies]
cw-orch = &quot;0.10.0&quot; # latest version as of writing this article
my-project = { path = &quot;../my-project&quot;}
# ...other dependencies
</code></pre>
<h2 id="defining-contract-interfaces"><a class="header" href="#defining-contract-interfaces">Defining Contract Interfaces</a></h2>
<p>The contract interface is a struct that provides accessible methods to deploy and interact with an instance of your contract. Let's see how to use it.</p>
<p>First, create a new file in the src directory of the interfaces package, and add it to the library declaration</p>
<pre><code class="language-bash">touch src/my-contract.rs
echo 'pub mod my_contract;' &gt;&gt; src/lib.rs
</code></pre>
<p>In your new file, define a struct for your contract interface and provide the [<code>Instantiate</code>|<code>Execute</code>|<code>Query</code>|<code>Migrate</code>] messages to the <code>contract</code> macro, which will generate fully-typed instantiate, execute, query, and migrate methods for this struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cw_orch::*;
// We use pub here to be able to import those messages directly
// from the interfaces crate in the next steps (scripting, intergation tests...)
pub use my_project::my_contract::{InstantiateMsg, ExecuteMsg, QueryMsg, MigrateMsg};

#[interface(InstantiateMsg, ExecuteMsg, QueryMsg, MigrateMsg)]
pub struct MyContract&lt;Chain&gt;;
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><em>If your entry point messages have any generic arguments, pull them out into new types before passing them into the macro.</em></p>
</blockquote>
<h2 id="constructor"><a class="header" href="#constructor">Constructor</a></h2>
<p>Next, you'll want to define the constructor for the interface we just defined. In order to do so, first include the contract interface (<code>instantiate</code>, <code>execute</code> and <code>query</code> functions) in your package :</p>
<pre><code class="language-bash">cargo add --path ../../my-contract
</code></pre>
<p>The generic <code>&lt;Chain&gt;</code> argument allows you to write functions for your interface that will be executable in different environments.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl&lt;Chain: CwEnv&gt; MyContract&lt;Chain&gt; {
    /// Construct a new instance of MyContract
    /// * `contract_id` - what your contract should be called in local state (*not* on-chain)
    /// * `chain` - the environment to deploy to
    pub fn new(contract_id: &amp;str, chain: Chain) -&gt; Self {
        // Use an absolute path
        let wasm_path = &quot;../../target/wasm32-unknown-unknown/release/my-contract.wasm&quot;;
       // OR give the contract name and set the ARTIFACTS_DIR environment variable to the artifacts folder
       let wasm_path = &quot;my-contract&quot;;
        Self(
            Contract::new(contract_id, chain)
            // Adds the wasm path for uploading to a node
            .with_wasm_path(wasm_path)
            // Adds the contract's endpoint functions for mocking
            .with_mock(Box::new(
                   ContractWrapper::new_with_empty(
                     my_contract::contract::execute,
                     my_contract::contract::instantiate,
                     my_contract::contract::query,
                ))),
        )
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Notice that we build the <code>Contract</code> instance and point it to the contract code using <code>with_wasm_path(...)</code>, where we provide the contract name <code>&quot;my-contract&quot;</code>.
This contract name will be used to search the artifacts directory (set by <code>ARTIFACTS_DIR</code> env variable) for a <code>my-contract.wasm</code> file.</p>
<p>Alternatively you can specify a path to the wasm artifact that's generated after running <code>RUSTFLAGS='-C link-arg=-s' cargo wasm</code> in the contract's directory. See the <a href="https://docs.cosmwasm.com/docs/1.0/getting-started/compile-contract/">CosmWasm documentation on compiling your contract</a> for more information.</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>Now you can start writing executable functions for your contracts with ensured type safety.
You can write functions that are generic or that can only be used called in a specific environment.
The environments that are currently supported are:</p>
<ol>
<li><a href="https://crates.io/crates/cw-multi-test">cw-multi-test</a></li>
<li>Blockchain daemons with CosmWasm enabled: <a href="https://github.com/CosmosContracts/juno">junod</a>, <a href="https://github.com/osmosis-labs/osmosis">osmosisd</a>,...</li>
</ol>
<h3 id="generic-function"><a class="header" href="#generic-function">Generic function</a></h3>
<p>Generic functions can be executed over any environment.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;Chain: CwEnv&gt; MyContract&lt;Chain&gt; {
    pub fn deploy(&amp;self, instantiate_msg: &amp;InstantiateMsg) -&gt; Result&lt;()&gt; {
        let sender = &amp;self.get_chain().sender();
        self.upload()?;
        let resp = self.instantiate(instantiate_msg, Some(&amp;sender), None)?;
        let my_contract_address = resp.instantiated_contract_address()?;
        log::info!(&quot;deployed my-contract to {}&quot;, my_contract_address);
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="daemon-only-functions"><a class="header" href="#daemon-only-functions">Daemon-only functions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MyContract&lt;Daemon&gt; {
    pub fn send_ibc_transaction(&amp;self, msg: &amp;ExecuteMsg) -&gt; Result&lt;String&gt; {
        let resp = self.execute(msg,None)?;
        let destination_port = resp.event_attr_value(&quot;ibc_transfer&quot;, &quot;destination_port&quot;)?;
        Ok(destination_port)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="mock-only-functions"><a class="header" href="#mock-only-functions">Mock-only functions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MyContract&lt;Mock&gt; {
    pub fn call_other_chain (&amp;self, msg: &amp;ExecuteMsg) -&gt; Result&lt;String&gt; {
        let resp = self.execute(msg,None)?;
        let destination_port = resp.event_attr_value(&quot;ibc_transfer&quot;, &quot;destination_port&quot;)?;
        Ok(destination_port)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="endpoint-function-generation"><a class="header" href="#endpoint-function-generation">Endpoint function generation</a></h3>
<h4 id="execution"><a class="header" href="#execution">Execution</a></h4>
<p>We can expand on this functionality with a simple macro that provides access to a contract's endpoints as callable functions. This functionality is only available if you have access to the message structs's crate.</p>
<blockquote>
<p>You will want to feature-flag the function generation to prevent cw-orchestrator entering as a dependency when building your contract.</p>
</blockquote>
<p>Here's an example with the macro shielded behind a &quot;interface&quot; feature flag:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cw_serde]
#[cfg_attr(feature = &quot;interface&quot;, derive(cw_orch::ExecuteFns))]
pub enum ExecuteMsg{
    Freeze {},
    UpdateAdmins { admins: Vec&lt;String&gt; },
    // Indicates that the call expects funds `Vec&lt;Coin&gt;`
    #[cfg_attr(feature = &quot;interface&quot;, payable)]
    Deposit {}
}

// If we now define a orchestrateable contract with this execute message
#[interface(InstantiateMsg, ExecuteMsg, QueryMsg, MigrateMsg)]
pub struct MyContract&lt;Chain&gt;;

// Then the message variants are available as functions on the struct through an &quot;ExecuteFns&quot; trait.
impl&lt;Chain: CwEnv + Clone&gt; MyContract&lt;Chain&gt; {
    pub fn test_macro(&amp;self) -&gt; Result&lt;(),CwOrchError&gt; {
        self.freeze()?;
        self.update_admins(vec![])?;
        self.deposit(&amp;[Coin::new(13,&quot;juno&quot;)])?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In order for the above code to work, you will need to follow those simple steps :</p>
<ol>
<li>
<p>Add the following line to your <code>packages/my-project.Cargo.toml</code>. This will allow to activate the interface feature for creating <code>ExecuteFns</code> outside of the crate</p>
<pre><code class="language-cargo">[features]
interface=[]
</code></pre>
</li>
<li>
<p>Add the following import in your <code>packages/interfaces/src/my-contract.rs</code> file :</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use my_project::my_contract::ExecuteMsgFns;
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h4 id="query"><a class="header" href="#query">Query</a></h4>
<p>Generating query functions is a similar process but has the added advantage of using the <code>cosmwasm-schema</code> return tags to detect the query's return type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cosmwasm_schema::cw_serde]
#[derive(QueryResponses)]
#[cfg_attr(feature = &quot;interface&quot;, derive(cw_orch::QueryFns))]
pub enum QueryMsg {
    /// Returns [`InfoResponse`]
    #[returns(InfoResponse)]
    Info {},
}

#[cosmwasm_schema::cw_serde]
pub struct InfoResponse {
    pub admin: Addr,
}

// If we now define a orchestrateable contract with this execute message
#[interface(InstantiateMsg, ExecuteMsg, QueryMsg, MigrateMsg)]
pub struct MyContract&lt;Chain&gt;;

// Then the message variants are available as functions on the struct through an &quot;ExecuteFns&quot; trait.
impl&lt;Chain: CwEnv + Clone&gt; MyContract&lt;Chain&gt; {
    pub fn test_macro(&amp;self) -&gt; Result&lt;(),CwOrchError&gt; {
        // No need to specify returned type!
        // info of type `InfoResponse` is returned
        let info = self.info()?;
        let admin: Addr = info.admin;
        Ok(())
    }
}

<span class="boring">}</span></code></pre></pre>
<p>In order to derive query functions, you NEED to serive the QueryResponses crate for your QueryMsgs struct. This is mandatory in order to ensure type-safety for all messages and responses.</p>
<p>This time, add the following import in your <code>packages/interfaces/src/my-contract.rs</code> file :
<code>rust use my_project::my_contract::QueryMsgFns; </code></p>
<h4 id="refinement"><a class="header" href="#refinement">Refinement</a></h4>
<p>You can also refine your contract interface manually to add more complex interactions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// interfaces/src/my_contract.rs
// Import the cw-orchestrator traits
use cw_orch::interface::*;
// ...

impl&lt;Chain: CwEnv&gt; MyContract&lt;Chain&gt; {
    pub fn new(contract_id: &amp;str, chain: Chain) -&gt; Self {
      // ...
    }

    /// Query the balance of an address
    /// `address` - the address to query
    pub fn balance(&amp;self, address: Addr) -&gt; Result&lt;BalanceResponse&gt; {
        let balance_query = QueryMsg::Balance { address };
        self.query(balance_query)
    }

    /// Update the balance of an address
    /// `address` - the address to update
    /// `balance` - the new balance
    pub fn update_balance(&amp;self, address: Addr, balance: Uint128) -&gt; Result&lt;Chain::TxResult&gt; {
        let update_balance_msg = ExecuteMsg::UpdateBalance {
            address,
            balance,
        };
        self.execute(update_balance_msg)
    }
}

<span class="boring">}</span></code></pre></pre>
<h2 id="learn-more"><a class="header" href="#learn-more">Learn more</a></h2>
<p>Got questions? Join the <a href="https://discord.gg/vAQVnz3tzj">Abstract Discord</a> and ask in the <code>#cw-orchestrator</code> channel.
Learn more about Abstract at <a href="https://abstract.money">abstract.money</a>.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://crates.io/crates/cw-orch">cw-orchestrator</a></li>
<li><a href="https://crates.io/crates/cw-plus-orc">cw-plus-orc</a></li>
<li><a href="https://crates.io/crates/abstract-cw-orch">Abstract Contract Interfaces</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h1>
<p>These variables are used by cw-orchestrator when interacting with a node using the <code>daemon</code> feature.</p>
<pre><code class="language-bash"># .env

# info, debug, trace
RUST_LOG=info

# where the contract wasms are located
ARTIFACTS_DIR=&quot;../artifacts&quot;

# where to store the state of your deployments
STATE_FILE=&quot;./daemon_state.json&quot;

# Mnemonics of the account that will be used to sign transactions
LOCAL_MNEMONIC=&quot;&quot;
TEST_MNEMONIC=&quot;&quot;
MAIN_MNEMONIC=&quot;&quot;
</code></pre>
<blockquote>
<p>IMPORTANT: Make sure to exclude the .env file in your gitignore.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-and-executing-scripts"><a class="header" href="#writing-and-executing-scripts">Writing and Executing Scripts</a></h1>
<p>Now that we have the interface written for our contract, we can start writing scripts to deploy and interact with it.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>Like before, we're going to setup a new folder for our scripts. This time, we'll call it <code>scripts</code> and initialize it as a binary crate:</p>
<pre><code class="language-bash">cargo init --bin scripts
</code></pre>
<blockquote>
<p>If your cargo project is a workspace, be sure to add <code>scripts</code> to the [workspace].members array at the workspace root.</p>
</blockquote>
<p>Your scripts will have basically the same dependencies as your contract interfaces, but with a few additions:</p>
<pre><code class="language-bash">cargo add --path ../packages/interfaces
</code></pre>
<p>and also add the <code>dotenv</code> crate:</p>
<pre><code class="language-bash">cargo add anyhow dotenv log
</code></pre>
<p>and, we must enable the <code>daemon</code> feature on <code>cw_orch</code></p>
<pre><code class="language-bash">cargo add cw_orch --features daemon
</code></pre>
<h2 id="main-function"><a class="header" href="#main-function">Main Function</a></h2>
<p>Now that we have our dependencies setup, we can start writing our script. Either create a new file in the <code>src</code> directory of the <code>scripts/src</code> package, or use the <code>main.rs</code> file that was created by default.</p>
<p>This function is mostly just boilerplate, so you can copy and paste it into your new script file. It will just call your function and give you nicer error traces:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    dotenv().ok();
    env_logger::init();

    use dotenv::dotenv;

    if let Err(ref err) = deploy_contract() {
        log::error!(&quot;{}&quot;, err);
        err.chain()
            .skip(1)
            .for_each(|cause| log::error!(&quot;because: {}&quot;, cause));

        // The backtrace is not always generated. Try to run this example
        // with `$env:RUST_BACKTRACE=1`.
        // log::debug!(&quot;backtrace: {:?}&quot;, err.backtrace());

        ::std::process::exit(1);
    }
}</code></pre></pre>
<h2 id="deployment-function"><a class="header" href="#deployment-function">Deployment Function</a></h2>
<p>First, we'll define a function that will deploy our contract to the chain. This function will setup the environment (connecting to the chain), deploy the contract, and return a <code>Result</code> with the contract address.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// scripts/src/my_contract.rs
use anyhow::Result;
use cw_orch::networks;
use cw_orch::{Addr, instantiate_daemon_env, NetworkInfo, DaemonOptionsBuilder};
// Traits for contract deployment
use cw_orch::interface::*;
use interfaces::my_contract::MyContract;

// Select the chain to deploy to
const NETWORK: NetworkInfo = networks::juno::UNI_6;
const CONTRACT_NAME: &amp;str = &quot;my-contract&quot;;

pub fn deploy_contract() -&gt; anyhow::Result&lt;Addr&gt; {
    // Create a runtime for the asynchronous actions
    let rt = Arc::new(tokio::runtime::Runtime::new().unwrap());

    // Specify the options for the blockchain daemon
    let options = DaemonOptionsBuilder::default()
        // or provide `chain_data`
        .network(NETWORK)
        .deployment_id(&quot;my_deployment_version&quot;)
        .build()?;

    // Setup the environment
    let (_sender, chain) = instantiate_daemon_env(&amp;rt, options)?;

    // Create a new instance of your contract interface
    let mut contract = MyContract::new(CONTRACT_NAME, chain);
    // Upload your contract
    contract.upload()?;

    // Instantiate your contract
    let init_msg = InstantiateMsg {
        // ...
    };
    // The second argument is the admin, the third is any coins to send with the init message
    contract.instantiate(&amp;init_msg, None, None)?;

    // Load and return the contract address
    let contract_addr = contract.address()?;
    Ok(contract_addr)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="additional-scripts"><a class="header" href="#additional-scripts">Additional Scripts</a></h3>
<p>So you have your contract deployed, but what now? You can write additional scripts to interact with your contract. For example, you can write a script to query the contract state, or to execute a contract method.</p>
<p>Here's an example of a script that queries the contract state:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// scripts/src/my_contract.rs
// use ...
use my_contract::{QueryMsg};
// ...

pub fn query_contract() -&gt; anyhow::Result&lt;()&gt; {
    // Setup the environment
    let rt = Arc::new(tokio::runtime::Runtime::new().unwrap());
    let options = DaemonOptionsBuilder::default()
        .network(NETWORK)
        .build()?;
    let (_sender, chain) = instantiate_daemon_env(&amp;rt, options)?;

    // Create a new instance of your contract interface
    let contract = MyContract::new(CONTRACT_NAME, chain);
    // Load the contract address (this will use the address set from the previous deploy script)
    let contract_addr = contract.address();
    // Query the contract
    let res = contract.query(&amp;QueryMsg::Balance {
      address: contract_addr,
    })?;
    // Print the result
    println!(&quot;{:?}&quot;, res);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>And one that executes a contract method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// scripts/src/my_contract.rs
use cw_orch::*;
use my_contract::{ExecuteMsg, ExecuteMsgFnsDerive};
// ...

pub fn execute_contract() -&gt; anyhow::Result&lt;()&gt; {
    // Setup the environment
    let rt = Arc::new(tokio::runtime::Runtime::new().unwrap());
    let options = DaemonOptionsBuilder::default()
        .network(NETWORK)
        .build()?;
    let (_sender, chain) = instantiate_daemon_env(&amp;rt, options)?;

    // Create a new instance of your contract interface
    let contract = MyContract::new(CONTRACT_NAME, chain);
    // Load the contract address (this will use the address set from the previous deploy script)
    let contract_addr = contract.address();
    // Execute a contract method
    let res = contract.execute(&amp;ExecuteMsg::UpdateBalance {
      address: contract_addr,
      balance: Uint128::from(1000000u128),
    }, None)?;
    // OR, if you're usincg the `ExecuteMsgFnsDerive` derive macro
    let res = contract.update_balance(contract_addr, Uint128::from(1000000u128))?;
    // Print the result
    println!(&quot;{:?}&quot;, res);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h1>
<p>To get started writing integration tests with cw-orchestrator, first add <code>cw-orchestrator</code> to your dependencies.</p>
<pre><code class="language-bash">cargo add --dev cw-orch
</code></pre>
<p>The following assumes that you have written your interfaces as described in <a href="tutorial/./quick_start/interfaces.html">Interfaces</a>.</p>
<h2 id="test-setup"><a class="header" href="#test-setup">Test Setup</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// contracts/my-contract/tests/integration_tests.rs  
use interfaces::MyContract;
use cw_orch::*;  
use semver::Version;
use my_contract::contract;
use my_contract::{ExecuteMsg};
  
fn setup() -&gt; anyhow::Result&lt;MyContract&lt;Mock&gt;&gt; {  
    let sender = Addr::unchecked(&quot;sender&quot;); 
    // note that we are instantiating the mock environment instead of the daemon_environment
    let (_, mock_chain) = instantiate_default_mock_env(&amp;sender)?;  

    let mut my_contract = MyContract::new(&quot;testing:contract&quot;, &amp;mock_chain);  

    // entrypoint endpoints for your contract
    my_contract.as_instance_mut().set_mock(Box::new(  
        ContractWrapper::new_with_empty(
            contract::execute,  
            contract::instantiate,  
            contract::query,  
        ),
    ));

    // &quot;upload&quot; the contract to the test environment
    // stores the code_id at the key &quot;testing:contract&quot;.
    my_contract.upload(); 
  
    Ok(my_contract)  
}  
  
#[test]  
fn test_something() -&gt; anyhow::Result&lt;()&gt; {  
  let my_contract = setup()?;  

  my_contract.instantiate(...)?;

  // execute on the contract
  my_contract.execute(&amp;ExecuteMsg::MyContractCall {
    something: Some(Addr::unchecked(&quot;arg&quot;))
  });
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration"><a class="header" href="#integration">Integration</a></h1>
<p>Now that you have your contract interfaces you can export a comprehensive deployment of your application that can easily be used by others.</p>
<p>The idea is simple. If you can provide an easy way for others to deploy your contracts/application to their environments, then you're making it extremely easy for them to use and build on your application.</p>
<p>As an example we will create a deployment for the <a href="https://abstract.money/">Abstract smart-contract framework</a>.</p>
<h2 id="the-deployment"><a class="header" href="#the-deployment">The deployment</a></h2>
<p>The deployment can be represented by a struct containing all the contracts that are uploaded and instantiated when the protocol is deployed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Our Abstract deployment
pub struct Abstract&lt;Chain: CwEnv&gt; {
    pub ans_host: AnsHost&lt;Chain&gt;,
    pub version_control: VersionControl&lt;Chain&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="implementing-deploy"><a class="header" href="#implementing-deploy">Implementing <code>Deploy</code></a></h3>
<p>Now we can implement the <code>cw_orch::Deploy</code> trait for the <code>Abstract</code> struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;Chain: CwEnv&gt; cw_orch::Deploy&lt;Chain&gt; for Abstract&lt;Chain&gt; {
    // We don't have a custom error type
    type Error = CwOrchError;
    type DeployData = semver::Version;

    fn store_on(chain: Chain) -&gt; Result&lt;Self, Self::Error&gt; {
        // &quot;abstract&quot; is a reserved keyword in rust!
        let mut abstrct = Self::new(chain);

        // Only include mock when `integration` flag is set
        if cfg!(feature = &quot;integration&quot;) {
            abstrct.ans_host
                .as_instance_mut()
                .set_mock(Box::new(ContractWrapper::new_with_empty(
                    ::ans_host::contract::execute,
                    ::ans_host::contract::instantiate,
                    ::ans_host::contract::query,
                )));

            abstrct.version_control.as_instance_mut().set_mock(Box::new(
                cw_multi_test::ContractWrapper::new_with_empty(
                    ::version_control::contract::execute,
                    ::version_control::contract::instantiate,
                    ::version_control::contract::query,
                ),
            ));
        }

        // Upload the contracts to the chain
        abstrct.ans_host.upload()?;
        abstrct.version_control.upload()?;

        Ok(abstrct)
    }

    fn deploy_on(chain: Chain, version: semver::Version) -&gt; Result&lt;Self, CwOrchError&gt; {        
        // ########### Upload ##############
        let abstrct = Self::store_on(chain)?;

        // ########### Instantiate ##############

        abstrct.ans_host.instantiate(
            &amp;abstract_os::ans_host::InstantiateMsg {},
            Some(sender),
            None,
        )?;

        abstrct.version_control.instantiate(
            &amp;abstract_os::version_control::InstantiateMsg {},
            Some(sender),
            None,
        )?;

        // ... 

        Ok(abstrct)
    }

    fn load_from(chain: Chain) -&gt; Result&lt;Self, Self::Error&gt; {
        let abstrct = Self::new(chain);
        Ok(abstrct)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Now <code>Abstract</code> is an application that can be deployed to a mock and real environment with <strong>one</strong> line of code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_test(mock: Mock) -&gt; Result&lt;(), CwOrchError&gt; {
    let version = &quot;1.0.0&quot;.parse().unwrap();
    // Deploy abstract
    let abstract_ = Abstract::deploy_on(mock.clone(), version)?;
}
<span class="boring">}</span></code></pre></pre>
<p>And then when setting up your own deployment you can load these applications to access their contracts (for accessing configuration, addresses, ...)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;Chain: CwEnv&gt; cw_orch::Deploy&lt;Chain&gt; for MyApplication&lt;Chain&gt; {
    /// ...
    fn deploy_on(chain: Chain, _data: Empty) -&gt; Result&lt;Self, CwOrchError&gt; {

        let abstract_: Abstract = Abstract::load_from(chain)?;

        /// ... do stuff with Abstract
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-cw-orchestrator"><a class="header" href="#contributing-to-cw-orchestrator">Contributing to cw-orchestrator</a></h1>
<p>Thank you for considering to contribute to the cw-orchestrator project! We appreciate your support and welcome contributions to help improve this multi-environment CosmWasm smart-contract scripting library. This document provides guidelines and instructions on how to contribute to the project effectively.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="contributing.html#code-of-conduct">Code of Conduct</a></li>
<li><a href="contributing.html#getting-started">Getting Started</a></li>
<li><a href="contributing.html#how-to-contribute">How to Contribute</a>
<ul>
<li><a href="contributing.html#reporting-bugs">Reporting Bugs</a></li>
<li><a href="contributing.html#suggesting-enhancements">Suggesting Enhancements</a></li>
<li><a href="contributing.html#code-contributions">Code Contributions</a>
<ul>
<li><a href="contributing.html#pull-requests">Pull Requests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="contributing.html#style-guide">Style Guide</a></li>
<li><a href="contributing.html#community">Community</a></li>
</ul>
<h2 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of Conduct</a></h2>
<p>By participating in this project, you are expected to uphold our <a href="CODE_OF_CONDUCT.html">Code of Conduct</a>. Please read the Code of Conduct to ensure that you follow the community guidelines and contribute positively to the project.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>To get started with contributing to the cw-orchestrator project, you should first familiarize yourself with the repository structure and the codebase. Please read the project's <a href="https://github.com/AbstractSDK/cw-orchestrator/">README</a> to understand the purpose, features, and usage of the cw-orchestrator library as well as its <a href="https://orchestrator.abstract.money">documentation</a>.</p>
<h2 id="how-to-contribute"><a class="header" href="#how-to-contribute">How to Contribute</a></h2>
<p>There are multiple ways to contribute to the cw-orchestrator project, including reporting bugs, suggesting enhancements, and submitting code contributions.</p>
<h2 id="reporting-bugs"><a class="header" href="#reporting-bugs">Reporting Bugs</a></h2>
<p>If you encounter any bugs or issues while using the cw-orchestrator library, please report them by creating a new issue in the <a href="https://github.com/AbstractSDK/cw-orchestrator/issues">issue tracker</a>. When reporting a bug, please provide the following information:</p>
<ul>
<li>A clear and descriptive title</li>
<li>A detailed description of the issue, including steps to reproduce it</li>
<li>Any relevant logs, error messages, or screenshots</li>
<li>Information about your environment, such as the OS, software versions, and hardware specifications</li>
</ul>
<h2 id="suggesting-enhancements"><a class="header" href="#suggesting-enhancements">Suggesting Enhancements</a></h2>
<p>We welcome suggestions for new features or improvements to the existing functionality of the cw-orchestrator library. To suggest an enhancement, create a new issue in the <a href="https://github.com/AbstractSDK/cw-orchestrator/issues">issue tracker</a> with the following information:</p>
<ul>
<li>A clear and descriptive title</li>
<li>A detailed explanation of the proposed enhancement, including its benefits and potential use cases</li>
<li>If applicable, any examples or mockups of the proposed feature</li>
</ul>
<h2 id="code-contributions"><a class="header" href="#code-contributions">Code Contributions</a></h2>
<p>To contribute code to the cw-orchestrator project, please follow these steps:</p>
<ol>
<li>Fork the repository to your own GitHub account.</li>
<li>Clone your fork to your local machine.</li>
<li>Create a new branch for your changes using the <code>git checkout -b feature/your-feature-name</code> command.</li>
<li>Make your changes and commit them with a clear and concise commit message.</li>
<li>Push your branch to your fork on GitHub.</li>
<li>Create a new pull request against the main branch of the cw-orchestrator repository.</li>
</ol>
<h2 id="pull-requests"><a class="header" href="#pull-requests">Pull Requests</a></h2>
<p>When submitting a pull request, please make sure that your code follows the <a href="contributing.html#style-guide">Style Guide</a> and that all tests pass. Please provide a detailed description of your changes, including the motivation for the changes and any potential impact on the project. This will help maintainers review your pull request more effectively.</p>
<h2 id="style-guide"><a class="header" href="#style-guide">Style Guide</a></h2>
<p>The cw-orchestrator project follows the Rust coding style and conventions. Please ensure that your code adheres to these guidelines to maintain consistency and readability throughout the codebase.</p>
<ul>
<li>Use proper indentation (4 spaces) and consistent formatting (<code>cargo fmt</code>).</li>
<li>Write descriptive variable and function names.</li>
<li>Use comments to explain complex or non-obvious code.</li>
<li>Follow the <a href="https://rust-lang.github.io/api-guidelines/">Rust API Guidelines</a> for API design.</li>
<li>Add documentation for public functions, types, and modules.</li>
<li>Write <a href="https://doc.rust-lang.org/rustdoc/documentation-tests.html">doc tests</a>
for public functions and methods.</li>
</ul>
<h2 id="community"><a class="header" href="#community">Community</a></h2>
<p>To join the cw-orchestrator community, please join the <a href="https://discord.gg/uch3Tq3aym">Abstract Discord server</a> and the <code>#cw-orchestrator</code> channel. You can also follow the project on <a href="https://twitter.com/AbstractSDK">Twitter</a> and <a href="https://github.com/AbstractSDK">GitHub</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
