<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Abstract SDK</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Build With Abstract</li><li class="chapter-item expanded "><a href="sdk/abstract_sdk.html"><strong aria-hidden="true">1.</strong> Abstract SDK - Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sdk/actor_model.html"><strong aria-hidden="true">1.1.</strong> Actor Model</a></li><li class="chapter-item expanded "><a href="sdk/account_abstraction.html"><strong aria-hidden="true">1.2.</strong> Account Abstraction</a></li><li class="chapter-item expanded "><a href="sdk/architecture.html"><strong aria-hidden="true">1.3.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="sdk/modules.html"><strong aria-hidden="true">1.4.</strong> Modules</a></li><li class="chapter-item expanded "><a href="sdk/ownership.html"><strong aria-hidden="true">1.5.</strong> Account Ownership</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.6.</strong> Interchain Abstract Accounts</div></li></ol></li><li class="chapter-item expanded "><a href="get_started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="get_started/installation.html"><strong aria-hidden="true">2.1.</strong> Installation - How to get started</a></li><li class="chapter-item expanded "><a href="get_started/account_creation.html"><strong aria-hidden="true">2.2.</strong> Account Creation</a></li><li class="chapter-item expanded "><a href="get_started/sdk.html"><strong aria-hidden="true">2.3.</strong> SDK</a></li><li class="chapter-item expanded "><a href="get_started/module_development.html"><strong aria-hidden="true">2.4.</strong> Module Development</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.1.</strong> Using the Template</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.2.</strong> Best Practices</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.3.</strong> Quality Assurance</div></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">Use Cases</li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Equilibrium</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 4t2 Finance</div></li><li class="chapter-item expanded affix "><li class="part-title">Resources and Support</li><li class="chapter-item expanded "><a href="ibc/index.html"><strong aria-hidden="true">5.</strong> Interchain Abstract Accounts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ibc/overview.html"><strong aria-hidden="true">5.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="ibc/spec.html"><strong aria-hidden="true">5.2.</strong> Specification</a></li></ol></li><li class="chapter-item expanded "><a href="video_and_content/index.html"><strong aria-hidden="true">6.</strong> Video and Content</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="video_and_content/interviews.html"><strong aria-hidden="true">6.1.</strong> Interviews</a></li><li class="chapter-item expanded "><a href="video_and_content/tutorials.html"><strong aria-hidden="true">6.2.</strong> Tutorials</a></li><li class="chapter-item expanded "><a href="video_and_content/faq.html"><strong aria-hidden="true">6.3.</strong> FAQ</a></li></ol></li><li class="chapter-item expanded "><a href="contributing.html">Contributing & Community</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="abstract">Abstract</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="abstract-light">Abstract Light</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Abstract SDK</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/AbstractSDK/contracts" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="abstract-sdk"><a class="header" href="#abstract-sdk">Abstract SDK</a></h1>
<p><img src="./assets/docs_bg.png" alt="SDK Background" /></p>
<p>Welcome to the Abstract documentation, your comprehensive guide to understanding and utilizing Abstract - the chain-agnostic CosmWasm framework that empowers developers to create, monetize, and deploy modular and scalable decentralized applications. This guide will walk you through essential concepts, key features, and real-world examples to help you harness the full potential of the Abstract ecosystem.</p>
<h2 id="what-is-abstract"><a class="header" href="#what-is-abstract">What is Abstract?</a></h2>
<p>Abstract is a cutting-edge smart contract framework designed for the CosmWasm ecosystem, enabling developers to build and monetize decentralized applications (dApps) using a modular component system. It simplifies and streamlines the dApp development process by offering an extensive library of off-the-shelf modules and a custom SDK for seamless integration with popular tools and services.</p>
<h2 id="key-features-and-benefits"><a class="header" href="#key-features-and-benefits">Key Features and Benefits</a></h2>
<ul>
<li>
<p>Modular Design: Abstract’s modular architecture allows developers to choose from a curated library of modules or develop their own using the Abstract SDK, enabling rapid development and customization.</p>
</li>
<li>
<p>Chain-Agnostic: Abstract is built to support various blockchain networks within the Cosmos ecosystem, giving developers the flexibility to choose the best-suited platform for their dApp.</p>
</li>
<li>
<p>Custom Governance: Abstract allows developers to create custom governance structures tailored to their application’s specific requirements, including integration with multi-signature wallets and DAOs.</p>
</li>
<li>
<p>Testing Infrastructure (cw-orchestrator): Abstract offers a vast integration testing library, enabling developers to quickly increase test coverage and ensure the reliability of their dApps.</p>
</li>
<li>
<p>Version Management: Abstract simplifies the process of upgrading installed modules, ensuring developers can quickly access new features and bug-fixes.</p>
</li>
<li>
<p>Ecosystem Integrations: Abstract is designed to work seamlessly with popular projects and services in the Cosmos ecosystem, such as:</p>
<ul>
<li>Dexes: WyndDex, Osmosis, Astroport, and TerraSwap</li>
<li>Oracles: Ojo Network (planned)</li>
<li>Wallets: Keplr, Cosmostation and Terra Station</li>
<li>Automation: CronCat and Lit Protocol (planned)</li>
</ul>
</li>
</ul>
<h3 id="reliable-development-funding"><a class="header" href="#reliable-development-funding">Reliable Development Funding</a></h3>
<p>Developers on the Abstract platform can earn ongoing revenue for their contributions by leveraging the platform’s tokenomics and community-driven incentives. They design and offer modules on the Module Marketplace and receive a portion of Abstract tokens from each sale. By participating in or forming Developer DAOs, developers gain access to funding for building modules and dApps, sharing profits among members. Furthermore, they can create modules based on user bounties, earning tokens for their efforts. This collaborative environment encourages the creation of top-quality modules, offering developers a continuous income stream and promoting value for all parties involved.</p>
<h2 id="use-cases-and-examples"><a class="header" href="#use-cases-and-examples">Use Cases and Examples</a></h2>
<h3 id="personalized-decentralized-finance-pdefi"><a class="header" href="#personalized-decentralized-finance-pdefi">Personalized Decentralized Finance (PDeFi)</a></h3>
<p>Developers can leverage Abstract’s modular architecture to quickly build Personalized DeFi applications. In contrast with traditionally DeFi, these applications aren’t required to custody the user’s assets. They can also be customized to meet the user’s specific requirements, such as integrating with their preferred oracle, wallet, or exchange. Abstract’s P-DeFi applications can be used to create custom financial products, such as:</p>
<ul>
<li>Dollar cost averaging (DCA)</li>
<li>Grid bot trading</li>
<li>Custom trading strategies</li>
<li>Permissioned asset markets</li>
</ul>
<p>All of which can have tweakable settings that are in the user’s control.</p>
<h3 id="nft-marketplaces"><a class="header" href="#nft-marketplaces">NFT Marketplaces</a></h3>
<p>Abstract’s SDK can be used to create customizable NFT marketplaces, allowing users to mint, trade, and manage digital assets on various Cosmos-based blockchains.</p>
<h3 id="governance-platforms"><a class="header" href="#governance-platforms">Governance Platforms</a></h3>
<p>Developers can utilize Abstract to create advanced governance platforms that support custom voting mechanisms and proposal systems for community-driven decision-making.</p>
<h3 id="cross-chain-interoperability"><a class="header" href="#cross-chain-interoperability">Cross-Chain Interoperability</a></h3>
<p>Abstract’s chain-agnostic nature enables developers to create dApps that can interact with multiple blockchains within the Cosmos ecosystem, facilitating cross-chain asset transfers and communication.</p>
<h3 id="decentralized-autonomous-organizations-daos"><a class="header" href="#decentralized-autonomous-organizations-daos">Decentralized Autonomous Organizations (DAOs)</a></h3>
<p>Abstract can be used to build and manage DAOs with custom governance structures, allowing communities to collaborate, make decisions, and allocate resources effectively.</p>
<h3 id="project-infrastructure"><a class="header" href="#project-infrastructure">Project Infrastructure</a></h3>
<p>Develop tooling for your dApps that help speed up work flows, work with your contracts from inside Rust, no need for JavaScript, use your own Rust projects codebases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abstract-sdk---overview"><a class="header" href="#abstract-sdk---overview">Abstract SDK - Overview</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-actor-model"><a class="header" href="#the-actor-model">The Actor Model</a></h1>
<p>The actor model is a computational model used in the design and implementation of CosmWasm smart contracts. It provides a secure and deterministic execution environment by employing message-based communication between individual actors. In this model, actors are autonomous entities capable of making local decisions, creating more actors, and responding to incoming messages. This model ensures encapsulation, concurrency control, and fault tolerance in distributed systems.</p>
<p>In CosmWasm, the actor model plays a crucial role in the architecture of smart contracts. The actor model helps ensure the following key principles within CosmWasm:</p>
<h3 id="1-encapsulation-and-isolation"><a class="header" href="#1-encapsulation-and-isolation">1. Encapsulation and Isolation</a></h3>
<p>Each smart contract operates as an isolated actor, processing messages independently. This isolation prevents interference and unintended side effects between contracts, enhancing security and reducing the risk of vulnerabilities like reentrancy attacks.</p>
<h3 id="2-sequential-message-processing"><a class="header" href="#2-sequential-message-processing">2. Sequential Message Processing</a></h3>
<p>Contracts can handle only one message at a time, ensuring deterministic execution and eliminating the need for call stacks. This approach prevents complex control flow issues and helps maintain the integrity of contract state.</p>
<h3 id="3-controlled-interactions"><a class="header" href="#3-controlled-interactions">3. Controlled Interactions</a></h3>
<p>When a contract wants to invoke another contract, it sends a message containing the necessary information. This controlled interaction allows for well-defined communication patterns, promoting modularity, and ensuring that contracts can safely collaborate without exposing their internal states.</p>
<h3 id="4-error-handling-and-atomic-transactions"><a class="header" href="#4-error-handling-and-atomic-transactions">4. Error Handling and Atomic Transactions</a></h3>
<p>A top-level message in CosmWasm represents a transaction that encompasses multiple sub-messages. If any sub-message encounters an error, the entire transaction is rolled back, reverting all state changes made within that transaction. This ensures atomicity and prevents inconsistent states in the contract</p>
<h2 id="relevance-to-the-abstract-account"><a class="header" href="#relevance-to-the-abstract-account">Relevance to the Abstract Account</a></h2>
<p>In the context of Abstract, each installed (or enabled) module acting as an independent actor provides distinct benefits.</p>
<h3 id="enhanced-security-through-state-isolation"><a class="header" href="#enhanced-security-through-state-isolation">Enhanced Security through State Isolation</a></h3>
<p>Each module’s state is securely isolated, significantly reducing the potential attack surface for malicious actors. This is crucial in safeguarding against threats such as re-entrancy attacks, where an attacker might exploit state changes during the execution of a function. In addition, if a module interfacing with an external protocol experiences a compromise, only the assets directly interacting with that protocol may be at risk, leaving the rest secure. This containment, driven by the actor model, minimizes potential losses by restricting the impact of breaches to the affected modules alone.</p>
<h3 id="composability-and-reliable-interactions"><a class="header" href="#composability-and-reliable-interactions">Composability and Reliable Interactions</a></h3>
<p>Developers can combine different functionalities due to the isolated, independent nature of modules. Each module communicates with others via message-passing while maintaining its state, promoting secure, reliable interactions. If any part of a multi-message interaction fails, the entire operation is rolled back, preserving the state’s integrity and ensuring all modules end up in a valid state post-interaction. This atomic processing is instrumental in maintaining consistent and reliable operations within an Abstract Account, enabling developers to build complex, versatile applications to cater to diverse user needs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="account-abstraction"><a class="header" href="#account-abstraction">Account Abstraction</a></h1>
<p>Account abstraction is a new core concept within blockchain and smart contract platforms, designed to streamline how users interact with decentralized applications (dApps). Its fundamental idea is to abstract away the complexities of blockchain interactions and provide a user-friendly, secure interface for transactions.</p>
<p>In traditional blockchain models, the transaction initiation process is typically rigid, where users directly sign and send transactions. Account abstraction simplifies this process by making the transaction initiation flexible and programmable. Essentially, it allows the transaction logic to be customized within smart contracts, vastly extending the capabilities of applications leveraging the abstraction.</p>
<p>Also see <a href="https://eips.ethereum.org/EIPS/eip-4337">EIP-4337</a> to read about account abstraction in the Ethereum ecosystem.</p>
<p>This concept of account abstraction, when implemented correctly, can provide numerous benefits:</p>
<ol>
<li><strong>Improved User Experience</strong>: Users can interact with smart contracts more seamlessly, without worrying about the underlying blockchain complexities. The interaction model can be tailored to align with familiar web2 paradigms.</li>
<li><strong>Enhanced Security</strong>: By shifting transaction logic to smart contracts, a variety of security checks can be implemented to guard against unauthorized transactions.</li>
<li><strong>Flexibility</strong>: It allows for innovative transaction types and enables advanced features such as transaction batching, atomic swaps, and more.</li>
<li><strong>Reliable Fee Payment</strong>: Account abstraction can enable smart contracts to pay for gas, thereby relieving end-users from managing volatile gas prices or even paying for gas at all.</li>
</ol>
<p>In the following sections, we’ll discuss how Abstract utilizes the concept of account abstraction, ensuring modularity, security, and scalability in applications built using the Abstract SDK.</p>
<h2 id="account-abstraction-on-abstract"><a class="header" href="#account-abstraction-on-abstract">Account Abstraction on Abstract</a></h2>
<blockquote>
<p>TODO: deepdive in the architecture instead of giving an overview here </p>
</blockquote>
<p>Within Abstract, account abstraction is a foundational component. Here, it manifests as abstracted accounts or smart contract wallets, which are designed to offer an easy-to-use and secure interaction model for users. These are known as Abstract Accounts.</p>
<p>Read <a href="sdk/./architecture">Abstract Account Architecture</a> for a deep dive on the implementation of account abstraction in Abstract.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abstract-account-architecture"><a class="header" href="#abstract-account-architecture">Abstract Account Architecture</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Abstract’s architecture revolves around the powerful combination of modularity, scalability, and security in decentralized applications. At the core of this architecture is the concept of account abstraction, which forms the foundation of Abstract’s functionality. For a detailed exploration of account abstraction, we recommend referring to the overview of <a href="sdk/./account_abstraction">Account Abstraction</a> . In the upcoming sections, we will delve deeper into the architecture of Abstract Accounts, providing insights into its design principles and components.</p>
<p>Every Abstract Account is fully owned and controllable by its owner. This ensures full user soveirgnity.</p>
<h2 id="abstract-account"><a class="header" href="#abstract-account">Abstract Account</a></h2>
<p>The Abstract platform uses a a smart-contract account architecture with two primary components: the <strong>Manager Contract</strong> and the <strong>Proxy Contract</strong>. </p>
<h3 id="manager-contract"><a class="header" href="#manager-contract">Manager Contract</a></h3>
<p>The Manager Contract serves as the orchestrator of the Abstract Account. It is responsible for various key operations, including:</p>
<ul>
<li><strong>User Authentication</strong>: Authenticating users and ensuring only approved entities can transact with the account.</li>
<li><strong>Permission Management</strong>: Managing permissions within the account and defining the operations a user or group can perform.</li>
<li><strong>Interaction Control</strong>: Regulating how the account interacts with external smart contracts and services through Abstract modules.</li>
</ul>
<h3 id="proxy-contract"><a class="header" href="#proxy-contract">Proxy Contract</a></h3>
<p>The Proxy Contract serves as the protective shield of the Account, taking care of:</p>
<ul>
<li><strong>Asset Isolation</strong>: Separating the account’s assets from direct user access, providing an added layer of security.</li>
<li><strong>Transaction Forwarding (Proxying)</strong>: Routing approved transactions from the <strong>Manager</strong> or other modules to the network.</li>
<li><strong>Interaction Interface</strong>: Acting as the primary interface for external contracts and services to interact with the Account.</li>
</ul>
<h3 id="account-interactions"><a class="header" href="#account-interactions">Account Interactions</a></h3>
<p>The diagram below depicts the User interacting with their account through the <strong>Manager</strong>, and proxying a call to an external contract through the <strong>Proxy</strong>.</p>
<pre class="mermaid">sequenceDiagram
    participant User
    participant Manager
    participant Proxy
    participant External Contract


    User-&gt;&gt;Manager: Command Request
    Manager-&gt;&gt;Proxy: Command Request
    Proxy-&gt;&gt;External Contract: External Call
    External Contract--&gt;&gt;Proxy: Response
    Proxy--&gt;&gt;Manager: Command Response
    Manager--&gt;&gt;User: Command Response
  
</pre>
<blockquote>
<p>Continue on to <a href="sdk/./modules">Modularity in Abstract</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modularity-in-abstract"><a class="header" href="#modularity-in-abstract">Modularity in Abstract</a></h1>
<p>Modularity is a fundamental design principle of the Abstract platform, contributing significantly to its flexibility and extensibility. A module in Abstract is a self-contained unit of functionality that can be added to an Abstract Account to extend its capabilities. This modular approach promotes the construction of bespoke applications, enhances the scalability of the system, and improves overall maintainability.</p>
<p>For application developers, modules simplify the development process by offering pre-built functionalities. Instead of building every aspect from scratch, developers can leverage modules either from Abstract’s extensive library or those crafted by other developers available in the module marketplace. Additionally, developers have the freedom to create custom modules using the <a href="https://docs.rs/abstract-sdk/latest/abstract_sdk">Abstract SDK</a>, tailoring them to specific application needs and even contributing back to the community.</p>
<h2 id="how-modules-work"><a class="header" href="#how-modules-work">How Modules Work</a></h2>
<p>In Abstract, the process of integrating these modules is managed through the Manager contract within an Abstract Account. The Manager keeps track of all installed modules, managing their permissions and interactions. This system enables the customization of each Account, as modules can be installed or uninstalled as per the user’s requirements, thereby adjusting the Account’s functionality.</p>
<p>From the perspective of a developer, the Abstract framework sets conventions and standards that allow leveraging existing modules during the development of new ones. This layer of abstraction saves considerable time and effort while promoting consistent design across different modules.</p>
<h2 id="security"><a class="header" href="#security">Security</a></h2>
<p>Security is a priority at Abstract, especially when it comes to the modules that extend the capabilities of an Abstract Account. Every module listed on the mainnet marketplaces must undergo a thorough auditing process before it’s made available to users. This process scrutinizes the module’s code, checking for potential vulnerabilities, and ensuring that it adheres to best security practices.</p>
<p>While no system can guarantee absolute security, this rigorous vetting process, coupled with the inherent security measures in Abstract and CosmWasm’s architecture, mitigates potential risks to a considerable extent.</p>
<p>The Abstract platform also maintains a Version Control (TODO link) for all the modules, allowing users and developers to track changes, understand the evolution of a module, and choose versions that have passed security audits. </p>
<p>TODO: add diagram</p>
<hr />
<p>TODO: below is not reviewed</p>
<h2 id="how-to-use-modules-in-your-project"><a class="header" href="#how-to-use-modules-in-your-project">How to Use Modules in Your Project</a></h2>
<p>Leveraging modules in your project can significantly simplify the development process, allowing you to deploy projects faster and more cost-effectively than building traditionally. By using pre-built, tested, and community-reviewed modules, you can focus on your project’s unique features while reducing development time and minimizing potential bugs.</p>
<p>Here’s an example of how modules can be leveraged for a decentralized finance (DeFi) project:</p>
<p>Imagine you want to create a DeFi application with the following features:</p>
<ul>
<li>A fungible token for your platform</li>
<li>Staking and delegation functionality</li>
<li>A governance system for community-driven decision-making</li>
<li>Integration with an oracle for fetching off-chain data</li>
</ul>
<p>Instead of building each feature from scratch, you can leverage Abstract’s off-the-shelf modules to implement these functionalities with ease. This not only saves time and resources but also ensures that your project benefits from the best practices established by the Abstract community.</p>
<p><strong>Step 1:</strong> Choose the relevant modules from the Abstract library, such as:
Token Module for fungible tokens
Staking Module for staking and delegation
Governance Module for creating a governance system
Oracle Module for integrating with an oracle service</p>
<p><strong>Step 2:</strong> Import the chosen modules into your project and configure them according to your requirements. This can include setting custom parameters, such as token supply, staking rewards, or voting thresholds.</p>
<p><strong>Step 3:</strong> Integrate the modules with your existing codebase, ensuring they work seamlessly with your project’s unique features. This can involve calling module functions, implementing hooks, or extending your data structures.</p>
<p><strong>Step 4:</strong> Test your dApp thoroughly to ensure the modules function as intended and do not introduce any unexpected behavior.</p>
<p>By leveraging Abstract’s modules in this way, you can rapidly build and deploy your DeFi project while benefiting from the robustness and flexibility of the Abstract ecosystem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="account-governance"><a class="header" href="#account-governance">Account Governance</a></h1>
<p>Governance structures are a wildly under-developed field in the realm of smart contract technology. Abstract allows for any custom governance type to be used with its chain-agnostic framework. While most users appreciate an easy-to-use interface to control their dApps, Abstract opts to provide two fully integrated governance choices (token-based and DaoDao integration coming soon) that ensure a seamless user experience.</p>
<p>When setting up governance for your dApp, you will be prompted to choose between supported governance types:</p>
<h2 id="monarchy"><a class="header" href="#monarchy">Monarchy</a></h2>
<p>In a monarchy, a single wallet has full control over the dApp. If you’re connected with a wallet, your address will be automatically inserted as the root user.
Visit our documentation to learn more about dApp ownership and sovereignty.</p>
<h2 id="multi-signature"><a class="header" href="#multi-signature">Multi-signature</a></h2>
<p>Multi-signature (“multisig”) governance is a governance structure that requires a subset of its members to approve an action before it can be executed. Though there are multiple implementations, Abstract uses the multisig module with the goal of providing the most flexible solution to users.</p>
<p>Knowledge about a few terms is required to configure your multisig:</p>
<p><em>Voter weight:</em> The weight that the voter has when voting on a proposal.</p>
<p><em>Threshold:</em> The minimal % of the total weight that needs to vote YES on a proposal for it to pass.</p>
<p><strong>Example:</strong>
Suppose you are building a DeFi platform using Abstract and want to implement multisig governance. You have five stakeholders, and you want at least 60% of the total voting weight to approve a proposal for it to pass.</p>
<ol>
<li>
<p>Set up the multisig module in your dApp.</p>
</li>
<li>
<p>Assign voter weights to each of the five stakeholders. For instance, A: 30%, B: 20%, C: 20%, D: 15%, and E: 15%.</p>
</li>
<li>
<p>Configure the multisig module with a 60% threshold.</p>
</li>
</ol>
<p>With this configuration, any proposal will require approval from stakeholders with a combined voting weight of at least 60% to be executed. This ensures a more democratic decision-making process and reduces the risk of a single stakeholder making unilateral decisions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-abstract"><a class="header" href="#getting-started-with-abstract">Getting Started With Abstract</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation---how-to-get-started"><a class="header" href="#installation---how-to-get-started">Installation - How to get started</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="account-creation"><a class="header" href="#account-creation">Account Creation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sdk"><a class="header" href="#sdk">SDK</a></h1>
<p><a href="https://docs.rs/abstract-sdk"><img src="https://docs.rs/abstract-sdk/badge.svg" alt="" /></a> <a href="https://crates.io/crates/abstract-sdk"><img src="https://img.shields.io/crates/v/abstract-sdk" alt="" /></a></p>
<p>Now that you’ve got your module set up you’re probably wondering how you can actually start programming. While you can create any regular smart-contract in a module, it’s not a use-case where our platform excels in. Instead we’ve created an <strong>account abstraction programming toolbox</strong> that allows you to easily control the Abstract Account, as well as <strong>create your own APIs</strong> that can be used by other developers to interact with your unique application. Composability galore!</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<p>The <code>abstract-sdk</code> crate is a toolbox for developers to create composable smart-contract APIs. It allows you to use composed functionality with a few keystrokes through it’s combination of supertraits and blanket implementations. Supertraits are Rust traits that have one or multiple trait bounds while a blanket implementation is a Rust implementation that is automatically implemented for every object that meets the trait bounds. The Abstract SDK makes use of both to achieve its modular design.</p>
<h3 id="features"><a class="header" href="#features">Features</a></h3>
<p>Features are the lowest-level traits that are contained within the SDK and they don’t have any trait bounds. They generally act as data accessor traits. I.e. if a struct implements a feature it means that it has some way to get the information required by that feature.</p>
<p>Here’s an example of such a feature:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::{ans_resolve::Resolve, AbstractSdkResult};
use abstract_core::objects::ans_host::AnsHost;
use cosmwasm_std::Deps;

/// Accessor to the Abstract Name Service.
pub trait AbstractNameService: Sized {
    /// Get the ANS host address.
    fn ans_host(&amp;self, deps: Deps) -&gt; AbstractSdkResult&lt;AnsHost&gt;;

    /// Construct the name service client.
    fn name_service&lt;'a&gt;(&amp;'a self, deps: Deps&lt;'a&gt;) -&gt; AbstractNameServiceClient&lt;Self&gt; {
        AbstractNameServiceClient {
            _base: self,
            deps,
            host: self.ans_host(deps).unwrap(),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Any structure that implements this traits has access to the Abstract Name Service, and thus has a way to resolve ANS entries. By composing these features it is possible to write advanced APIs that are automatically implemented on objects that support its required features.</p>
<p>Now instead of letting you implement these traits yourself, we’ve already gone ahead and implemented them for the App and Adapter structs. Here’s the implementation for the App:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;
        Error: ContractError,
        CustomInitMsg,
        CustomExecMsg,
        CustomQueryMsg,
        CustomMigrateMsg,
        ReceiveMsg,
        SudoMsg,
    &gt; AbstractNameService
    for AppContract&lt;
        Error,
        CustomInitMsg,
        CustomExecMsg,
        CustomQueryMsg,
        CustomMigrateMsg,
        ReceiveMsg,
        SudoMsg,
    &gt;
{
    fn ans_host(&amp;self, deps: Deps) -&gt; AbstractSdkResult&lt;AnsHost&gt; {
        // Retrieve the ANS host address from the base state.
        Ok(self.base_state.load(deps.storage)?.ans_host)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>So when you’re building your application the module struct already has the features and data required to do the basic abstract operations. With this we can start creating more advanced functionality.</p>
<blockquote>
<p>Other structs that implement a feature without being module bases are called <em>Feature Objects</em>.</p>
</blockquote>
<h3 id="apis"><a class="header" href="#apis">APIs</a></h3>
<p>The Abstract API objects are structs that expose some smart-contract functionality and that can only be retrieved if a contract or feature-object implements the required features/api traits. If the trait constraints for the API is met it is automatically implemented on the object and hence allows you to retrieve the API object.</p>
<h4 id="example"><a class="header" href="#example">Example</a></h4>
<p>The <a href="https://docs.rs/abstract-sdk/latest/abstract_sdk/apis/bank"><code>Bank</code></a> API allows developers to transfer assets from and to the Account through their module object. We now want to use this API to create a <code>Splitter</code> API that splits the transfer of some amount of funds between a set of receivers.</p>
<pre><code class="language-rust ignore">#![allow(unused)]
use crate::{AbstractSdkResult, TransferInterface};
use abstract_core::objects::AnsAsset;
use cosmwasm_std::{Addr, CosmosMsg, Deps, StdResult, Uint128};

// Trait to retrieve the Splitter object
// Depends on the ability to transfer funds
pub trait SplitterInterface: TransferInterface {
    fn splitter&lt;'a&gt;(&amp;'a self, deps: Deps&lt;'a&gt;) -&gt; Splitter&lt;Self&gt; {
        Splitter { base: self, deps }
    }
}

// Implement for every object that can transfer funds
impl&lt;T&gt; SplitterInterface for T where T: TransferInterface {}

#[derive(Clone)]
pub struct Splitter&lt;'a, T: SplitterInterface&gt; {
    base: &amp;'a T,
    deps: Deps&lt;'a&gt;,
}

impl&lt;'a, T: SplitterInterface&gt; Splitter&lt;'a, T&gt; {
    /// Split an asset to multiple users
    pub fn split(&amp;self, asset: AnsAsset, receivers: &amp;[Addr]) -&gt; AbstractSdkResult&lt;Vec&lt;CosmosMsg&gt;&gt; {
        // split the asset between all receivers
        let receives_each = AnsAsset {
            amount: asset
                .amount
                .multiply_ratio(Uint128::one(), Uint128::from(receivers.len() as u128)),
            ..asset
        };

        // Retrieve the bank API
        let bank = self.base.bank(self.deps);
        let transfer_msgs: AbstractSdkResult&lt;_&gt; = receivers
            .iter()
            .map(|receiver| {
                // Construct the transfer message
                bank.transfer(vec![&amp;receives_each], receiver)
            })
            .collect();

        transfer_msgs
    }
}</code></pre>
<p>These APIs can then be used by any contract that implements its required traits, in this case the <code>TransferInterface</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use abstract_sdk::features::{AccountIdentification, AbstractNameService, ModuleIdentification};
</span><span class="boring">use cosmwasm_std::{StdResult, Deps, MessageInfo, CosmosMsg, Addr};
</span><span class="boring">use abstract_sdk::feature_objects::AnsHost;
</span><span class="boring">use abstract_sdk::AbstractSdkResult;
</span><span class="boring">pub struct MyContract {
</span><span class="boring">    
</span><span class="boring">}
</span><span class="boring">impl AccountIdentification for MyContract {
</span><span class="boring">    fn proxy_address(&amp;self, _deps: Deps) -&gt; AbstractSdkResult&lt;Addr&gt; {
</span><span class="boring">        Ok(Addr::unchecked(&quot;just_an_example&quot;))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl ModuleIdentification for MyContract {
</span><span class="boring">    fn module_id(&amp;self) -&gt; &amp;'static str { &quot;my_contract&quot; }
</span><span class="boring">}
</span><span class="boring">impl AbstractNameService for MyContract {
</span><span class="boring">    fn ans_host(&amp;self, _deps: Deps) -&gt; AbstractSdkResult&lt;AnsHost&gt; {
</span><span class="boring">        Ok(AnsHost{address: Addr::unchecked(&quot;just_an_example&quot;)})
</span><span class="boring">    }
</span><span class="boring">}
</span>use abstract_sdk::TransferInterface;

fn forward_deposit(deps: Deps, my_contract: MyContract, message_info: MessageInfo) -&gt; AbstractSdkResult&lt;CosmosMsg&gt; {
    // Construct the API object
    let bank: Bank = my_contract.bank(deps);
    // Use the API to deposit the coins
    let send_deposit_to_vault_msg = bank.deposit_coins(message_info.funds)?;
    Ok(send_deposit_to_vault_msg)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="available-api-objects"><a class="header" href="#available-api-objects">Available API Objects</a></h3>
<p>The following API objects are available in the Abstract SDK:</p>
<ul>
<li><a href="https://docs.rs/abstract-sdk/latest/abstract_sdk/struct.Bank.html"><code>Bank</code></a></li>
<li><a href="https://docs.rs/abstract-sdk/latest/abstract_sdk/struct.Executor.html"><code>Executor</code></a></li>
<li><a href="https://docs.rs/abstract-sdk/latest/abstract_sdk/struct.App.html"><code>App</code></a></li>
<li><a href="https://docs.rs/abstract-sdk/latest/abstract_sdk/struct.Adapter.html"><code>Adapter</code></a></li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Add <code>abstract-sdk</code> to your <code>Cargo.toml</code> by running:</p>
<pre><code class="language-bash">cargo add abstract-sdk
</code></pre>
<p>Then import the prelude in your contract. This will ensure that you have access to all the traits which should help your IDE with auto-completion.</p>
<pre><code class="language-rust ignore">use abstract_sdk::prelude::*;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="module-creation"><a class="header" href="#module-creation">Module Creation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ibc"><a class="header" href="#ibc">IBC</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interchain-abstract-accounts"><a class="header" href="#interchain-abstract-accounts">Interchain Abstract Accounts</a></h1>
<p>Interchain Abstract Accounts is Abstract’s solution to chain-agnostic accounts. It allows users to create an account on one chain and use it on any other chain that supports Abstract. This is achieved by using a combination of the <a href="https://ibcprotocol.org/">Inter-Blockchain Communication (IBC) protocol</a> and the <a href="ibc/../introduction/architecture.html">Abstract Accounts</a>.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>IAA allow users to interact with any smart-contract on any chain using their local account. This mechanism is powered by a set of Abstract smart-contracts that will dispatch messages that users send locally to a distant chain.</p>
<h3 id="account-creation-1"><a class="header" href="#account-creation-1">Account creation</a></h3>
<p>The first step of using Interchain Abstract Account is creating a remote account. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abstract-ibc"><a class="header" href="#abstract-ibc">Abstract IBC</a></h1>
<h2 id="synopsis"><a class="header" href="#synopsis">Synopsis</a></h2>
<p>This standard document specifies packet data structure, state machine handling logic, and encoding details for the transfer of messages and creation of Abstract accounts over an IBC channel between a client and a host on separate chains. The state machine logic presented allows for safe multi-chain account creation and execution.</p>
<h3 id="motivation"><a class="header" href="#motivation">Motivation</a></h3>
<p>Users of a set of chains connected over the IBC protocol might wish to interact with smart-contracts and dapps present on another chain than their origin, while not having to onboard the distant chain, create a new wallet or transfer the necessary funds to this other chain. This application-layer standard describes a protocol for interacting with a distant chain and creating abstract account on chains connected with IBC which preserves asset ownership, limits the impact of Byzantine faults, and requires no additional permissioning.</p>
<h3 id="definitions"><a class="header" href="#definitions">Definitions</a></h3>
<p>The Abstract IBC Account interface is described in the following guide and the specifications are roughly presented here</p>
<h3 id="desired-properties"><a class="header" href="#desired-properties">Desired Properties</a></h3>
<ul>
<li>Preservation of account and funds ownership</li>
<li>All interactions that can be done by a local account should be possible for a distant account as well.</li>
</ul>
<h2 id="technical-specification"><a class="header" href="#technical-specification">Technical Specification</a></h2>
<h3 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h3>
<p>Only one packet data type is added in this spec to be able to interact across IBC chains</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PacketMsg {
    /// Chain of the client
    pub client_chain: String,
    /// Amount of retries to attempt if packet returns with StdAck::Error
    pub retries: u8,
    pub account_id: AccountId,
    /// Callback performed after receiving an StdAck::Result
    pub callback_info: Option&lt;CallbackInfo&gt;,
    /// execute the custom host function
    pub action: HostAction,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="execution"><a class="header" href="#execution">Execution</a></h4>
<ul>
<li>
<p>client_chain specifies the chain from which the message originates. Once a channel is created between client and host, this channel will always be checked to match the registered configuration</p>
</li>
<li>
<p>account_id specifies the account that is calling the action on the local chain.</p>
</li>
<li>
<p>action specifies what the remote chain should execute upon receiving this packet</p>
</li>
</ul>
<h4 id="acknowledgement"><a class="header" href="#acknowledgement">Acknowledgement</a></h4>
<p>When the action is executed on the remote chain, it can either be successful or yield an error.</p>
<ul>
<li>
<p>retries specifies the number of attemps left to submit the packet. In case an error is yielded by the remote chain, the original packet will be sent back to the original chain and retried as long as retries &gt; 0. Because IBC actions are asynchronous, some packets may need to wait other packet to go through before they can be executed. This parameter allows the packet action to fail multiple times before it’s indeed sent across a channel</p>
</li>
<li>
<p>call_back_info is an optional object that specifies any action that needs to be executed after the packet has been sucessfully executed and a positive (<code>StdAck::Result</code>) acknowledgement has been transfered back. </p>
</li>
</ul>
<h4 id="cross-chain-trace"><a class="header" href="#cross-chain-trace">Cross chain trace</a></h4>
<p>Because accounts created across chains using the IAA protocol are controlled by an account located on a remote chain, the <code>account_id</code> parameter should specify which chain is calling an action. In order to follow which chains a message is called from, the IBC Abstract module leverages the <code>AccountId::trace</code> field. An account is wether <code>AccountTrace::Local</code> or <code>AccountTrace::Remote</code>. When a PacketMsg is sent across an IBC channel, the account id is transformed in the following manner : </p>
<ul>
<li>If it was <code>AccountTrace::Local</code> before transfer, it turns into an <code>AccountTrace::Remote</code> account with one chain in the associated vector being the chain calling the <code>PacketMsg</code> (<code>PacketMsg::client_chain</code>)</li>
<li>If it was <code>AccountTrace::Remote</code> before transfer, it stays remote and the <code>client_chain</code> field is added to the associated vector.</li>
</ul>
<p>This allows full traceability of the account creations and calls. </p>
<p>We don’t need to enforce the same logic as with token transfer (channel + port), because we don’t need fungibility here. Only the chains on which the accounts exist is important</p>
<p>The acknowledgement data type describes whether the transfer succeeded or failed, and the reason for failure (if any).</p>
<pre><code class="language-typescript">type FungibleTokenPacketAcknowledgement = FungibleTokenPacketSuccess | FungibleTokenPacketError;

interface FungibleTokenPacketSuccess {
  // This is binary 0x01 base64 encoded
  result: &quot;AQ==&quot;
}

interface FungibleTokenPacketError {
  error: string
}
</code></pre>
<p>Note that both the <code>FungibleTokenPacketData</code> as well as <code>FungibleTokenPacketAcknowledgement</code> must be JSON-encoded (not Protobuf encoded) when they serialized into packet data. Also note that <code>uint256</code> is string encoded when converted to JSON, but must be a valid decimal number of the form <code>[0-9]+</code>.</p>
<p>The fungible token transfer bridge module tracks escrow addresses associated with particular channels in state. Fields of the <code>ModuleState</code> are assumed to be in scope.</p>
<pre><code class="language-typescript">interface ModuleState {
  channelEscrowAddresses: Map&lt;Identifier, string&gt;
}
</code></pre>
<h3 id="sub-protocols"><a class="header" href="#sub-protocols">Sub-protocols</a></h3>
<p>The sub-protocols described herein should be implemented in a “fungible token transfer bridge” module with access to a bank module and to the IBC routing module.</p>
<h4 id="port--channel-setup"><a class="header" href="#port--channel-setup">Port &amp; channel setup</a></h4>
<p>The <code>setup</code> function must be called exactly once when the module is created (perhaps when the blockchain itself is initialised) to bind to the appropriate port and create an escrow address (owned by the module).</p>
<pre><code class="language-typescript">function setup() {
  capability = routingModule.bindPort(&quot;bank&quot;, ModuleCallbacks{
    onChanOpenInit,
    onChanOpenTry,
    onChanOpenAck,
    onChanOpenConfirm,
    onChanCloseInit,
    onChanCloseConfirm,
    onRecvPacket,
    onTimeoutPacket,
    onAcknowledgePacket,
    onTimeoutPacketClose
  })
  claimCapability(&quot;port&quot;, capability)
}
</code></pre>
<p>Once the <code>setup</code> function has been called, channels can be created through the IBC routing module between instances of the fungible token transfer module on separate chains.</p>
<p>An administrator (with the permissions to create connections &amp; channels on the host state machine) is responsible for setting up connections to other state machines &amp; creating channels
to other instances of this module (or another module supporting this interface) on other chains. This specification defines packet handling semantics only, and defines them in such a fashion
that the module itself doesn’t need to worry about what connections or channels might or might not exist at any point in time.</p>
<h4 id="routing-module-callbacks"><a class="header" href="#routing-module-callbacks">Routing module callbacks</a></h4>
<h5 id="channel-lifecycle-management"><a class="header" href="#channel-lifecycle-management">Channel lifecycle management</a></h5>
<p>Both machines <code>A</code> and <code>B</code> accept new channels from any module on another machine, if and only if:</p>
<ul>
<li>The channel being created is unordered.</li>
<li>The version string is <code>ics20-1</code>.</li>
</ul>
<pre><code class="language-typescript">function onChanOpenInit(
  order: ChannelOrder,
  connectionHops: [Identifier],
  portIdentifier: Identifier,
  channelIdentifier: Identifier,
  counterpartyPortIdentifier: Identifier,
  counterpartyChannelIdentifier: Identifier,
  version: string) =&gt; (version: string, err: Error) {
  // only unordered channels allowed
  abortTransactionUnless(order === UNORDERED)
  // assert that version is &quot;ics20-1&quot; or empty
  // if empty, we return the default transfer version to core IBC
  // as the version for this channel
  abortTransactionUnless(version === &quot;ics20-1&quot; || version === &quot;&quot;)
  // allocate an escrow address
  channelEscrowAddresses[channelIdentifier] = newAddress()
  return &quot;ics20-1&quot;, nil
}
</code></pre>
<pre><code class="language-typescript">function onChanOpenTry(
  order: ChannelOrder,
  connectionHops: [Identifier],
  portIdentifier: Identifier,
  channelIdentifier: Identifier,
  counterpartyPortIdentifier: Identifier,
  counterpartyChannelIdentifier: Identifier,
  counterpartyVersion: string) =&gt; (version: string, err: Error) {
  // only unordered channels allowed
  abortTransactionUnless(order === UNORDERED)
  // assert that version is &quot;ics20-1&quot;
  abortTransactionUnless(counterpartyVersion === &quot;ics20-1&quot;)
  // allocate an escrow address
  channelEscrowAddresses[channelIdentifier] = newAddress()
  // return version that this chain will use given the
  // counterparty version
  return &quot;ics20-1&quot;, nil
}
</code></pre>
<pre><code class="language-typescript">function onChanOpenAck(
  portIdentifier: Identifier,
  channelIdentifier: Identifier,
  counterpartyChannelIdentifier: Identifier,
  counterpartyVersion: string) {
  // port has already been validated
  // assert that counterparty selected version is &quot;ics20-1&quot;
  abortTransactionUnless(counterpartyVersion === &quot;ics20-1&quot;)
}
</code></pre>
<pre><code class="language-typescript">function onChanOpenConfirm(
  portIdentifier: Identifier,
  channelIdentifier: Identifier) {
  // accept channel confirmations, port has already been validated, version has already been validated
}
</code></pre>
<pre><code class="language-typescript">function onChanCloseInit(
  portIdentifier: Identifier,
  channelIdentifier: Identifier) {
    // always abort transaction
    abortTransactionUnless(FALSE)
}
</code></pre>
<pre><code class="language-typescript">function onChanCloseConfirm(
  portIdentifier: Identifier,
  channelIdentifier: Identifier) {
  // no action necessary
}
</code></pre>
<h5 id="packet-relay"><a class="header" href="#packet-relay">Packet relay</a></h5>
<p>In plain English, between chains <code>A</code> and <code>B</code>:</p>
<ul>
<li>When acting as the source zone, the bridge module escrows an existing local asset denomination on the sending chain and mints vouchers on the receiving chain.</li>
<li>When acting as the sink zone, the bridge module burns local vouchers on the sending chains and unescrows the local asset denomination on the receiving chain.</li>
<li>When a packet times-out, local assets are unescrowed back to the sender or vouchers minted back to the sender appropriately.</li>
<li>Acknowledgement data is used to handle failures, such as invalid denominations or invalid destination accounts. Returning
an acknowledgement of failure is preferable to aborting the transaction since it more easily enables the sending chain
to take appropriate action based on the nature of the failure.</li>
</ul>
<p><code>sendFungibleTokens</code> must be called by a transaction handler in the module which performs appropriate signature checks, specific to the account owner on the host state machine.</p>
<pre><code class="language-typescript">function sendFungibleTokens(
  denomination: string,
  amount: uint256,
  sender: string,
  receiver: string,
  sourcePort: string,
  sourceChannel: string,
  timeoutHeight: Height,
  timeoutTimestamp: uint64): uint64 {
    prefix = &quot;{sourcePort}/{sourceChannel}/&quot;
    // we are the source if the denomination is not prefixed
    source = denomination.slice(0, len(prefix)) !== prefix
    if source {
      // determine escrow account
      escrowAccount = channelEscrowAddresses[sourceChannel]
      // escrow source tokens (assumed to fail if balance insufficient)
      bank.TransferCoins(sender, escrowAccount, denomination, amount)
    } else {
      // receiver is source chain, burn vouchers
      bank.BurnCoins(sender, denomination, amount)
    }

    // create FungibleTokenPacket data
    data = FungibleTokenPacketData{denomination, amount, sender, receiver}

    // send packet using the interface defined in ICS4
    sequence = handler.sendPacket(
      getCapability(&quot;port&quot;),
      sourcePort,
      sourceChannel,
      timeoutHeight,
      timeoutTimestamp,
      data
    )

    return sequence
}
</code></pre>
<p><code>onRecvPacket</code> is called by the routing module when a packet addressed to this module has been received.</p>
<pre><code class="language-typescript">function onRecvPacket(packet: Packet) {
  FungibleTokenPacketData data = packet.data
  // construct default acknowledgement of success
  FungibleTokenPacketAcknowledgement ack = FungibleTokenPacketAcknowledgement{true, null}
  prefix = &quot;{packet.sourcePort}/{packet.sourceChannel}/&quot;
  // we are the source if the packets were prefixed by the sending chain
  source = data.denom.slice(0, len(prefix)) === prefix
  if source {
    // receiver is source chain: unescrow tokens
    // determine escrow account
    escrowAccount = channelEscrowAddresses[packet.destChannel]
    // unescrow tokens to receiver (assumed to fail if balance insufficient)
    err = bank.TransferCoins(escrowAccount, data.receiver, data.denom.slice(len(prefix)), data.amount)
    if (err !== nil)
      ack = FungibleTokenPacketAcknowledgement{false, &quot;transfer coins failed&quot;}
  } else {
    prefix = &quot;{packet.destPort}/{packet.destChannel}/&quot;
    prefixedDenomination = prefix + data.denom
    // sender was source, mint vouchers to receiver (assumed to fail if balance insufficient)
    err = bank.MintCoins(data.receiver, prefixedDenomination, data.amount)
    if (err !== nil)
      ack = FungibleTokenPacketAcknowledgement{false, &quot;mint coins failed&quot;}
  }
  return ack
}
</code></pre>
<p><code>onAcknowledgePacket</code> is called by the routing module when a packet sent by this module has been acknowledged.</p>
<pre><code class="language-typescript">function onAcknowledgePacket(
  packet: Packet,
  acknowledgement: bytes) {
  // if the transfer failed, refund the tokens
  if (!ack.success)
    refundTokens(packet)
}
</code></pre>
<p><code>onTimeoutPacket</code> is called by the routing module when a packet sent by this module has timed-out (such that it will not be received on the destination chain).</p>
<pre><code class="language-typescript">function onTimeoutPacket(packet: Packet) {
  // the packet timed-out, so refund the tokens
  refundTokens(packet)
}
</code></pre>
<p><code>refundTokens</code> is called by both <code>onAcknowledgePacket</code>, on failure, and <code>onTimeoutPacket</code>, to refund escrowed tokens to the original sender.</p>
<pre><code class="language-typescript">function refundTokens(packet: Packet) {
  FungibleTokenPacketData data = packet.data
  prefix = &quot;{packet.sourcePort}/{packet.sourceChannel}/&quot;
  // we are the source if the denomination is not prefixed
  source = data.denom.slice(0, len(prefix)) !== prefix
  if source {
    // sender was source chain, unescrow tokens back to sender
    escrowAccount = channelEscrowAddresses[packet.srcChannel]
    bank.TransferCoins(escrowAccount, data.sender, data.denom, data.amount)
  } else {
    // receiver was source chain, mint vouchers back to sender
    bank.MintCoins(data.sender, data.denom, data.amount)
  }
}
</code></pre>
<pre><code class="language-typescript">function onTimeoutPacketClose(packet: Packet) {
  // can't happen, only unordered channels allowed
}
</code></pre>
<h4 id="using-the-memo-field"><a class="header" href="#using-the-memo-field">Using the Memo Field</a></h4>
<p>Note: Since earlier versions of this specification did not include a <code>memo</code> field, implementations must ensure that the new packet data is still compatible with chains that expect the old packet data. A legacy implementation MUST be able to unmarshal a new packet data with an empty string memo into the legacy <code>FungibleTokenPacketData</code> struct. Similarly, an implementation supporting <code>memo</code> must be able to unmarshal a legacy packet data into the current struct with the <code>memo</code> field set to the empty string.</p>
<p>The <code>memo</code> field is not used within transfer, however it may be used either for external off-chain users (i.e. exchanges) or for middleware wrapping transfer that can parse and execute custom logic on the basis of the passed in memo. If the memo is intended to be parsed and interpreted by higher-level middleware, then these middleware are advised to namespace their additions to the memo string so that they do not overwrite each other. Chains should ensure that there is some length limit on the entire packet data to ensure that the packet does not become a DOS vector. However, these do not need to be protocol-defined limits. If the receiver cannot accept a packet because of length limitations, this will lead to a timeout on the sender side.</p>
<p>Memos that are intended to be read by higher level middleware for custom execution must be structured so that different middleware can read relevant data in the memo intended for them without interfering with data intended for other middlewares.</p>
<p>Thus, for any memo that is meant to be interpreted by the state machine; it is recommended that the memo is a JSON object with each middleware reserving a key that it can read into and retrieve relevant data. This way the memo can be constructed to pass in information such that multiple middleware can read the memo without interference from each other.</p>
<p>Example:</p>
<pre><code class="language-json">{
  &quot;wasm&quot;: {
    &quot;address&quot;: &quot;contractAddress&quot;,
    &quot;arguments&quot;: &quot;marshalledArguments&quot;,
  },
  &quot;callback&quot;: &quot;contractAddress&quot;,
  &quot;router&quot;: &quot;routerArgs&quot;,
}
</code></pre>
<p>Here, the “wasm”, “callback”, and “router” fields are all intended for separate middlewares that will exclusively read those fields respectively in order to execute their logic. This allows multiple modules to read from the memo. Middleware should take care to reserve a unique key so that they do not accidentally read data intended for a different module. This issue can be avoided by some off-chain registry of keys already in-use in the JSON object.</p>
<h4 id="reasoning"><a class="header" href="#reasoning">Reasoning</a></h4>
<h5 id="correctness"><a class="header" href="#correctness">Correctness</a></h5>
<p>This implementation preserves both fungibility &amp; supply.</p>
<p>Fungibility: If tokens have been sent to the counterparty chain, they can be redeemed back in the same denomination &amp; amount on the source chain.</p>
<p>Supply: Redefine supply as unlocked tokens. All send-recv pairs sum to net zero. Source chain can change supply.</p>
<h5 id="multi-chain-notes"><a class="header" href="#multi-chain-notes">Multi-chain notes</a></h5>
<p>This specification does not directly handle the “diamond problem”, where a user sends a token originating on chain A to chain B, then to chain D, and wants to return it through D -&gt; C -&gt; A — since the supply is tracked as owned by chain B (and the denomination will be “{portOnD}/{channelOnD}/{portOnB}/{channelOnB}/denom”), chain C cannot serve as the intermediary. It is not yet clear whether that case should be dealt with in-protocol or not — it may be fine to just require the original path of redemption (and if there is frequent liquidity and some surplus on both paths the diamond path will work most of the time). Complexities arising from long redemption paths may lead to the emergence of central chains in the network topology.</p>
<p>In order to track all of the denominations moving around the network of chains in various paths, it may be helpful for a particular chain to implement a registry which will track the “global” source chain for each denomination. End-user service providers (such as wallet authors) may want to integrate such a registry or keep their own mapping of canonical source chains and human-readable names in order to improve UX.</p>
<h4 id="optional-addenda"><a class="header" href="#optional-addenda">Optional addenda</a></h4>
<ul>
<li>Each chain, locally, could elect to keep a lookup table to use short, user-friendly local denominations in state which are translated to and from the longer denominations when sending and receiving packets. </li>
<li>Additional restrictions may be imposed on which other machines may be connected to &amp; which channels may be established.</li>
</ul>
<h2 id="backwards-compatibility"><a class="header" href="#backwards-compatibility">Backwards Compatibility</a></h2>
<p>Not applicable.</p>
<h2 id="forwards-compatibility"><a class="header" href="#forwards-compatibility">Forwards Compatibility</a></h2>
<p>This initial standard uses version “ics20-1” in the channel handshake.</p>
<p>A future version of this standard could use a different version in the channel handshake,
and safely alter the packet data format &amp; packet handler semantics.</p>
<h2 id="example-implementations"><a class="header" href="#example-implementations">Example Implementations</a></h2>
<ul>
<li>Implementation of ICS 20 in Go can be found in <a href="https://github.com/cosmos/ibc-go">ibc-go repository</a>.</li>
<li>Implementation of ICS 20 in Rust can be found in <a href="https://github.com/cosmos/ibc-rs">ibc-rs repository</a>.</li>
</ul>
<h2 id="history"><a class="header" href="#history">History</a></h2>
<p>Jul 15, 2019 - Draft written</p>
<p>Jul 29, 2019 - Major revisions; cleanup</p>
<p>Aug 25, 2019 - Major revisions, more cleanup</p>
<p>Feb 3, 2020 - Revisions to handle acknowledgements of success &amp; failure</p>
<p>Feb 24, 2020 - Revisions to infer source field, inclusion of version string</p>
<p>July 27, 2020 - Re-addition of source field</p>
<p>Nov 11, 2022 - Addition of a memo field</p>
<h2 id="copyright"><a class="header" href="#copyright">Copyright</a></h2>
<p>All content herein is licensed under <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="video-and-content"><a class="header" href="#video-and-content">Video and Content</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interviews"><a class="header" href="#interviews">Interviews</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-abstract-sdk"><a class="header" href="#contributing-to-abstract-sdk">Contributing to Abstract SDK</a></h1>
<p>Thank you for considering to contribute to the Abstract SDK project! We appreciate your support and welcome contributions to help improve this multi-environment CosmWasm smart-contract scripting library. This document provides guidelines and instructions on how to contribute to the project effectively.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="contributing.html#code-of-conduct">Code of Conduct</a></li>
<li><a href="contributing.html#getting-started">Getting Started</a></li>
<li><a href="contributing.html#how-to-contribute">How to Contribute</a>
<ul>
<li><a href="contributing.html#reporting-bugs">Reporting Bugs</a></li>
<li><a href="contributing.html#suggesting-enhancements">Suggesting Enhancements</a></li>
<li><a href="contributing.html#code-contributions">Code Contributions</a>
<ul>
<li><a href="contributing.html#pull-requests">Pull Requests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="contributing.html#style-guide">Style Guide</a></li>
<li><a href="contributing.html#community">Community</a></li>
</ul>
<h2 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of Conduct</a></h2>
<p>By participating in this project, you are expected to uphold our <a href="CODE_OF_CONDUCT.html">Code of Conduct</a>. Please read the Code of Conduct to ensure that you follow the community guidelines and contribute positively to the project.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>To get started with contributing to the Abstract SDK project, you should first familiarize yourself with the repository structure and the codebase. Please read the project’s <a href="https://github.com/AbstractSDK/contracts/">README</a> to understand the purpose, features, and usage of the Abstract SDK library as well as its <a href="https://docs.abstract.money">documentation</a>.</p>
<h2 id="how-to-contribute"><a class="header" href="#how-to-contribute">How to Contribute</a></h2>
<p>There are multiple ways to contribute to the Abstract SDK project, including reporting bugs, suggesting enhancements, and submitting code contributions.</p>
<h2 id="reporting-bugs"><a class="header" href="#reporting-bugs">Reporting Bugs</a></h2>
<p>If you encounter any bugs or issues while using the Abstract SDK library, please report them by creating a new issue in the <a href="https://github.com/AbstractSDK/contracts/issues">issue tracker</a>. When reporting a bug, please provide the following information:</p>
<ul>
<li>A clear and descriptive title</li>
<li>A detailed description of the issue, including steps to reproduce it</li>
<li>Any relevant logs, error messages, or screenshots</li>
<li>Information about your environment, such as the OS, software versions, and hardware specifications</li>
</ul>
<h2 id="suggesting-enhancements"><a class="header" href="#suggesting-enhancements">Suggesting Enhancements</a></h2>
<p>We welcome suggestions for new features or improvements to the existing functionality of the Abstract SDK library. To suggest an enhancement, create a new issue in the <a href="https://github.com/AbstractSDK/contracts/issues">issue tracker</a> with the following information:</p>
<ul>
<li>A clear and descriptive title</li>
<li>A detailed explanation of the proposed enhancement, including its benefits and potential use cases</li>
<li>If applicable, any examples or mockups of the proposed feature</li>
</ul>
<h2 id="code-contributions"><a class="header" href="#code-contributions">Code Contributions</a></h2>
<p>To contribute code to the Abstract SDK project, please follow these steps:</p>
<ol>
<li>Fork the repository to your own GitHub account.</li>
<li>Clone your fork to your local machine.</li>
<li>Create a new branch for your changes using the <code>git checkout -b feature/your-feature-name</code> command.</li>
<li>Make your changes and commit them with a clear and concise commit message.</li>
<li>Push your branch to your fork on GitHub.</li>
<li>Create a new pull request against the main branch of the Abstract SDK repository.</li>
</ol>
<h2 id="pull-requests"><a class="header" href="#pull-requests">Pull Requests</a></h2>
<p>When submitting a pull request, please make sure that your code follows the <a href="contributing.html#style-guide">Style Guide</a> and that all tests pass. Please provide a detailed description of your changes, including the motivation for the changes and any potential impact on the project. This will help maintainers review your pull request more effectively.</p>
<h2 id="style-guide"><a class="header" href="#style-guide">Style Guide</a></h2>
<p>The Abstract SDK project follows the Rust coding style and conventions. Please ensure that your code adheres to these guidelines to maintain consistency and readability throughout the codebase.</p>
<ul>
<li>Use proper indentation (4 spaces) and consistent formatting (<code>cargo fmt</code>).</li>
<li>Write descriptive variable and function names.</li>
<li>Use comments to explain complex or non-obvious code.</li>
<li>Follow the <a href="https://rust-lang.github.io/api-guidelines/">Rust API Guidelines</a> for API design.</li>
<li>Add documentation for public functions, types, and modules.</li>
<li>Write <a href="https://doc.rust-lang.org/rustdoc/documentation-tests.html">doc tests</a>
for public functions and methods.</li>
</ul>
<h2 id="community"><a class="header" href="#community">Community</a></h2>
<p>To join the Abstract SDK community, please join the <a href="https://discord.gg/uch3Tq3aym">Abstract Discord server</a> and the <code>#Abstract SDK</code> channel. You can also follow the project on <a href="https://twitter.com/AbstractSDK">Twitter</a> and <a href="https://github.com/AbstractSDK">GitHub</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
